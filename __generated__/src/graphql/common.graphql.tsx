/* 0e65149826eb5d36f9234a827fc5fd69765bc0af
 * This file is automatically generated by graphql-let. */

import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * The `DateTime` scalar type represents a DateTime
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  DateTime: any;
  /**
   * The `Date` scalar type represents a Date
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  Date: any;
};

export type Query = {
  __typename?: 'Query';
  badges?: Maybe<Array<Maybe<BadgeObjectType>>>;
  /**
   * Return comments filtered by query params.
   *
   * The `search_term` is used to search from comment creator usernames and comment text.
   *
   * Results are sorted by creation time.
   *
   * Only allowed for authenticated users that have verified their accounts.
   *
   * Results are paginated.
   */
  comments?: Maybe<PaginatedCommentObjectType>;
  /**
   * Return user profile of the user making the query.
   *
   * Only allowed for authenticated users.
   */
  userMe?: Maybe<UserObjectType>;
  /** Superusers or users who haven't entered a referral code cannot be queried. */
  user?: Maybe<UserObjectType>;
  /**
   * Return the dynamic page slugs that frontend needs to build a
   * `sitemap.xml`.
   */
  sitemap?: Maybe<SitemapObjectType>;
  /**
   * Return threads filtered by query params.
   *
   * The `search_term` is used to search from thread title and text.
   *
   * Results are sorted either manually based on query params or by secret Skole AI-
   * powered algorithms. If the `user` argument is passed the results will always
   * just be sorted by creation time.
   *
   * Only allowed for authenticated users that have verified their accounts.
   *
   * Results are paginated.
   */
  threads?: Maybe<PaginatedThreadObjectType>;
  /**
   * Return starred threads of the user making the query.
   *
   * Results are sorted by creation time. Return an empty list for unauthenticated
   * users.
   *
   * Only allowed for authenticated users that have verified their accounts.
   *
   * Results are paginated.
   */
  starredThreads?: Maybe<PaginatedThreadObjectType>;
  thread?: Maybe<ThreadObjectType>;
  /**
   * Return all activity of to the user making the query.
   *
   * Results are sorted by creation time.
   *
   * Only allowed for authenticated users that have verified their accounts.
   *
   * Results are paginated.
   */
  activities?: Maybe<PaginatedActivityObjectType>;
  /**
   * Return limited amount of activity of user making the query for a preview.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  activityPreview?: Maybe<Array<Maybe<ActivityObjectType>>>;
};


export type QueryCommentsArgs = {
  user?: Maybe<Scalars['String']>;
  thread?: Maybe<Scalars['String']>;
  ordering?: Maybe<Scalars['String']>;
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
};


export type QueryUserArgs = {
  slug?: Maybe<Scalars['String']>;
};


export type QueryThreadsArgs = {
  searchTerm?: Maybe<Scalars['String']>;
  user?: Maybe<Scalars['String']>;
  ordering?: Maybe<Scalars['String']>;
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
};


export type QueryStarredThreadsArgs = {
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
};


export type QueryThreadArgs = {
  slug?: Maybe<Scalars['String']>;
};


export type QueryActivitiesArgs = {
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
};

/** Models a badge awarded for a user, e.g `Moderator`. */
export type BadgeObjectType = {
  __typename?: 'BadgeObjectType';
  id: Scalars['ID'];
  tier: BadgeTier;
  name: Scalars['String'];
  description: Scalars['String'];
};

/** An enumeration. */
export enum BadgeTier {
  /** Diamond */
  Diamond = 'DIAMOND',
  /** Gold */
  Gold = 'GOLD',
  /** Silver */
  Silver = 'SILVER',
  /** Bronze */
  Bronze = 'BRONZE'
}

/**
 * Models one comment posted on a comment thread.
 *
 * Results are paginated.
 */
export type PaginatedCommentObjectType = {
  __typename?: 'PaginatedCommentObjectType';
  page?: Maybe<Scalars['Int']>;
  pages?: Maybe<Scalars['Int']>;
  hasNext?: Maybe<Scalars['Boolean']>;
  hasPrev?: Maybe<Scalars['Boolean']>;
  count?: Maybe<Scalars['Int']>;
  objects?: Maybe<Array<Maybe<CommentObjectType>>>;
};

export type CommentObjectType = {
  __typename?: 'CommentObjectType';
  id: Scalars['ID'];
  user?: Maybe<UserObjectType>;
  text: Scalars['String'];
  file: Scalars['String'];
  image: Scalars['String'];
  thread?: Maybe<ThreadObjectType>;
  comment?: Maybe<CommentObjectType>;
  modified: Scalars['DateTime'];
  created: Scalars['DateTime'];
  replyComments: Array<CommentObjectType>;
  score?: Maybe<Scalars['Int']>;
  vote?: Maybe<VoteObjectType>;
  replyCount?: Maybe<Scalars['Int']>;
  imageThumbnail?: Maybe<Scalars['String']>;
  isOwn: Scalars['Boolean'];
};

/**
 * Models one user on the platform.
 *
 * The following fields are private, meaning they are returned only if the user is
 * querying one's own profile: `email`, `verified`, `badge_progresses`,
 * `selected_badge_progress`, `referral_codes`, `school`, `subject`, and all
 * `permission` fields.
 *
 * For instances that are not the user's own user profile, these fields will return a
 * `null` value.
 */
export type UserObjectType = {
  __typename?: 'UserObjectType';
  id: Scalars['ID'];
  slug?: Maybe<Scalars['String']>;
  username: Scalars['String'];
  email?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  bio: Scalars['String'];
  avatar?: Maybe<Scalars['String']>;
  selectedBadgeProgress?: Maybe<BadgeProgressObjectType>;
  score?: Maybe<Scalars['Int']>;
  verified?: Maybe<Scalars['Boolean']>;
  created: Scalars['DateTime'];
  commentReplyEmailPermission?: Maybe<Scalars['Boolean']>;
  threadCommentEmailPermission?: Maybe<Scalars['Boolean']>;
  newBadgeEmailPermission?: Maybe<Scalars['Boolean']>;
  commentReplyPushPermission?: Maybe<Scalars['Boolean']>;
  threadCommentPushPermission?: Maybe<Scalars['Boolean']>;
  newBadgePushPermission?: Maybe<Scalars['Boolean']>;
  threadCount?: Maybe<Scalars['Int']>;
  commentCount?: Maybe<Scalars['Int']>;
  avatarThumbnail?: Maybe<Scalars['String']>;
  rank?: Maybe<Scalars['String']>;
  badges?: Maybe<Array<Maybe<BadgeObjectType>>>;
  badgeProgresses?: Maybe<Array<Maybe<BadgeProgressObjectType>>>;
  referralCodes?: Maybe<Array<Maybe<ReferralCodeObjectType>>>;
  unreadActivityCount?: Maybe<Scalars['Int']>;
  fcmToken?: Maybe<Scalars['String']>;
};

/**
 * Models the progress of a user's single badge.
 *
 * E.g. User testuser2 can have a progress of 5/15 comments to get a 'Commenter' badge.
 */
export type BadgeProgressObjectType = {
  __typename?: 'BadgeProgressObjectType';
  badge: BadgeObjectType;
  user: UserObjectType;
  progress: Scalars['Int'];
  steps?: Maybe<Scalars['Int']>;
};


/** Models one referral code that a user can use to invite new users. */
export type ReferralCodeObjectType = {
  __typename?: 'ReferralCodeObjectType';
  code: Scalars['String'];
  usages: Scalars['Int'];
};

export type ThreadObjectType = {
  __typename?: 'ThreadObjectType';
  id: Scalars['ID'];
  title: Scalars['String'];
  text: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  image: Scalars['String'];
  user?: Maybe<UserObjectType>;
  modified: Scalars['DateTime'];
  created: Scalars['DateTime'];
  starred?: Maybe<Scalars['Boolean']>;
  score?: Maybe<Scalars['Int']>;
  vote?: Maybe<VoteObjectType>;
  starCount?: Maybe<Scalars['Int']>;
  commentCount?: Maybe<Scalars['Int']>;
  imageThumbnail?: Maybe<Scalars['String']>;
};

/** Models one vote on either a comment or a thread. */
export type VoteObjectType = {
  __typename?: 'VoteObjectType';
  id: Scalars['ID'];
  user?: Maybe<UserObjectType>;
  status?: Maybe<Scalars['Int']>;
  comment?: Maybe<CommentObjectType>;
  thread?: Maybe<ThreadObjectType>;
};

export type SitemapObjectType = {
  __typename?: 'SitemapObjectType';
  threads: Array<SitemapEntryObjectType>;
  users: Array<SitemapEntryObjectType>;
};

export type SitemapEntryObjectType = {
  __typename?: 'SitemapEntryObjectType';
  slug?: Maybe<Scalars['String']>;
  modified?: Maybe<Scalars['Date']>;
};


/**
 * Models one thread.
 *
 * Results are paginated.
 */
export type PaginatedThreadObjectType = {
  __typename?: 'PaginatedThreadObjectType';
  page?: Maybe<Scalars['Int']>;
  pages?: Maybe<Scalars['Int']>;
  hasNext?: Maybe<Scalars['Boolean']>;
  hasPrev?: Maybe<Scalars['Boolean']>;
  count?: Maybe<Scalars['Int']>;
  objects?: Maybe<Array<Maybe<ThreadObjectType>>>;
};

/**
 * Models a single activity of a users activity feed.
 *
 * Results are paginated.
 */
export type PaginatedActivityObjectType = {
  __typename?: 'PaginatedActivityObjectType';
  page?: Maybe<Scalars['Int']>;
  pages?: Maybe<Scalars['Int']>;
  hasNext?: Maybe<Scalars['Boolean']>;
  hasPrev?: Maybe<Scalars['Boolean']>;
  count?: Maybe<Scalars['Int']>;
  objects?: Maybe<Array<Maybe<ActivityObjectType>>>;
};

/** Models a single activity of a users activity feed. */
export type ActivityObjectType = {
  __typename?: 'ActivityObjectType';
  id: Scalars['ID'];
  causingUser?: Maybe<UserObjectType>;
  comment?: Maybe<CommentObjectType>;
  badgeProgress?: Maybe<BadgeProgressObjectType>;
  read?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /**
   * Start a thread or remove the star if it already exists.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  star?: Maybe<StarMutationPayload>;
  /**
   * Upvote, downvote or remove a vote from a thread or a comment.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  vote?: Maybe<VoteMutationPayload>;
  /**
   * Register a new user.
   *
   * Check if there is an existing user with that email or username. Check that account
   * is not deactivated. By default, set the user's account as unverified. After
   * successful registration, the user is allowed to use a referral code.
   */
  register?: Maybe<RegisterMutationPayload>;
  /**
   * Receive the token that was sent by email.
   *
   * If the token is valid, verify the user's account.
   */
  verifyAccount?: Maybe<VerifyAccountMutationPayload>;
  /**
   * Use a referral code and make the user fully registered.
   *
   * After successfully entering the referral code, send account verification email.
   */
  useReferralCode?: Maybe<UseReferralCodeMutationPayload>;
  /**
   * Send the verification email again.
   *
   * Return an error in the following cases:
   * - A user account with the provided email address was not found.
   * - An unknown error while sending the email occurred.
   * - The user has already verified one's account.
   */
  resendVerificationEmail?: Maybe<ResendVerificationEmailMutation>;
  /**
   * Send password reset email.
   *
   * Return an error in the following cases:
   * - A user account with the provided email address was not found.
   * - An unknown error while sending the email occurred.
   */
  sendPasswordResetEmail?: Maybe<SendPasswordResetEmailMutationPayload>;
  /**
   * Change user's password without knowing the old password.
   *
   * Receive the token that was sent by email. Revoke refresh token and require the user
   * to log in again with one's new password.
   */
  resetPassword?: Maybe<ResetPasswordMutationPayload>;
  /**
   * Obtain JSON web token and user information.
   *
   * Non-verified users can still login.
   */
  login?: Maybe<LoginMutationPayload>;
  /**
   * Delete JSON web token cookie and logout.
   *
   * This sets the `Set-Cookie` header so that the JWT token cookie gets automatically
   * deleted in frontend.
   */
  logout?: Maybe<LogoutMutation>;
  /**
   * Change password with a requirement of knowing the old password.
   *
   * Only allowed for authenticated users.
   */
  changePassword?: Maybe<ChangePasswordMutationPayload>;
  /**
   * Update public profile fields for a user.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  updateProfile?: Maybe<UpdateProfileMutationPayload>;
  /**
   * Update private account settings for a user.
   *
   * Only allowed for authenticated users.
   */
  updateAccountSettings?: Maybe<UpdateAccountSettingsMutationPayload>;
  /**
   * Permanently delete the account.
   *
   * The user must confirm his password.
   *
   * Only allowed for authenticated users.
   */
  deleteUser?: Maybe<DeleteUserMutationPayload>;
  /**
   * Change the badge which progress the user currently tracks.
   *
   * Only allowed for authenticated users.
   */
  updateSelectedBadge?: Maybe<UpdateSelectedBadgeMutationPayload>;
  /**
   * Register FCM token for a user.
   *
   * Only allowed for authenticated users.
   */
  registerFcmToken?: Maybe<RegisterFcmTokenMutationPayload>;
  /** Email the user with a link to a zip file containing **all** of their data. */
  myData?: Maybe<MyDataMutation>;
  /**
   * Create a new thread.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  createThread?: Maybe<CreateThreadMutationPayload>;
  /**
   * Delete a thread.
   *
   * Only allowed for users that are the creators of the object.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  deleteThread?: Maybe<DeleteThreadMutationPayload>;
  /** Submit a message via the contact form. */
  createContactMessage?: Maybe<ContactMutationPayload>;
  /**
   * Create a new comment.
   *
   * Attachments are popped of for unauthenticated users. The `user` field must match
   * with the ID of the user making the query to save the user making the query as the
   * author of the comment. This way even authenticated users can create anonymous
   * comments by setting the `user` field as `null`.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  createComment?: Maybe<CreateCommentMutationPayload>;
  /**
   * Update an existing comment.
   *
   * Only allowed for users that are the creators of the object.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  updateComment?: Maybe<UpdateCommentMutationPayload>;
  /**
   * Delete a comment.
   *
   * Only allowed for users that are the creators of the object.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  deleteComment?: Maybe<DeleteCommentMutationPayload>;
  /**
   * Mark a single activity read/unread.
   *
   * Only allowed for users that are the creators of the object.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  markActivityAsRead?: Maybe<MarkActivityAsReadMutationPayload>;
  /**
   * Mark all activities of the given user as read.
   *
   * Only allowed for authenticated users that have verified their accounts.
   */
  markAllActivitiesAsRead?: Maybe<MarkAllActivitiesAsReadMutation>;
};


export type MutationStarArgs = {
  input: StarMutationInput;
};


export type MutationVoteArgs = {
  input: VoteMutationInput;
};


export type MutationRegisterArgs = {
  input: RegisterMutationInput;
};


export type MutationVerifyAccountArgs = {
  input: VerifyAccountMutationInput;
};


export type MutationUseReferralCodeArgs = {
  input: UseReferralCodeMutationInput;
};


export type MutationSendPasswordResetEmailArgs = {
  input: SendPasswordResetEmailMutationInput;
};


export type MutationResetPasswordArgs = {
  input: ResetPasswordMutationInput;
};


export type MutationLoginArgs = {
  input: LoginMutationInput;
};


export type MutationChangePasswordArgs = {
  input: ChangePasswordMutationInput;
};


export type MutationUpdateProfileArgs = {
  input: UpdateProfileMutationInput;
};


export type MutationUpdateAccountSettingsArgs = {
  input: UpdateAccountSettingsMutationInput;
};


export type MutationDeleteUserArgs = {
  input: DeleteUserMutationInput;
};


export type MutationUpdateSelectedBadgeArgs = {
  input: UpdateSelectedBadgeMutationInput;
};


export type MutationRegisterFcmTokenArgs = {
  input: RegisterFcmTokenMutationInput;
};


export type MutationCreateThreadArgs = {
  input: CreateThreadMutationInput;
};


export type MutationDeleteThreadArgs = {
  input: DeleteThreadMutationInput;
};


export type MutationCreateContactMessageArgs = {
  input: ContactMutationInput;
};


export type MutationCreateCommentArgs = {
  input: CreateCommentMutationInput;
};


export type MutationUpdateCommentArgs = {
  input: UpdateCommentMutationInput;
};


export type MutationDeleteCommentArgs = {
  input: DeleteCommentMutationInput;
};


export type MutationMarkActivityAsReadArgs = {
  input: MarkActivityAsReadMutationInput;
};

/**
 * Start a thread or remove the star if it already exists.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type StarMutationPayload = {
  __typename?: 'StarMutationPayload';
  star?: Maybe<StarObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  starred?: Maybe<Scalars['Boolean']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Models a star that a user has placed on a thread. */
export type StarObjectType = {
  __typename?: 'StarObjectType';
  id: Scalars['ID'];
  user: UserObjectType;
  thread: ThreadObjectType;
};

export type ErrorType = {
  __typename?: 'ErrorType';
  field: Scalars['String'];
  messages: Array<Scalars['String']>;
};

export type StarMutationInput = {
  thread: Scalars['ID'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Upvote, downvote or remove a vote from a thread or a comment.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type VoteMutationPayload = {
  __typename?: 'VoteMutationPayload';
  vote?: Maybe<VoteObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  targetScore?: Maybe<Scalars['Int']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type VoteMutationInput = {
  status: Scalars['Int'];
  comment?: Maybe<Scalars['ID']>;
  thread?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Register a new user.
 *
 * Check if there is an existing user with that email or username. Check that account
 * is not deactivated. By default, set the user's account as unverified. After
 * successful registration, the user is allowed to use a referral code.
 */
export type RegisterMutationPayload = {
  __typename?: 'RegisterMutationPayload';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type RegisterMutationInput = {
  username: Scalars['String'];
  email: Scalars['String'];
  password: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Receive the token that was sent by email.
 *
 * If the token is valid, verify the user's account.
 */
export type VerifyAccountMutationPayload = {
  __typename?: 'VerifyAccountMutationPayload';
  token?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type VerifyAccountMutationInput = {
  token?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Use a referral code and make the user fully registered.
 *
 * After successfully entering the referral code, send account verification email.
 */
export type UseReferralCodeMutationPayload = {
  __typename?: 'UseReferralCodeMutationPayload';
  code: Scalars['String'];
  email: Scalars['String'];
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type UseReferralCodeMutationInput = {
  code: Scalars['String'];
  email: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Send the verification email again.
 *
 * Return an error in the following cases:
 * - A user account with the provided email address was not found.
 * - An unknown error while sending the email occurred.
 * - The user has already verified one's account.
 */
export type ResendVerificationEmailMutation = {
  __typename?: 'ResendVerificationEmailMutation';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
};

/**
 * Send password reset email.
 *
 * Return an error in the following cases:
 * - A user account with the provided email address was not found.
 * - An unknown error while sending the email occurred.
 */
export type SendPasswordResetEmailMutationPayload = {
  __typename?: 'SendPasswordResetEmailMutationPayload';
  email: Scalars['String'];
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type SendPasswordResetEmailMutationInput = {
  email: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Change user's password without knowing the old password.
 *
 * Receive the token that was sent by email. Revoke refresh token and require the user
 * to log in again with one's new password.
 */
export type ResetPasswordMutationPayload = {
  __typename?: 'ResetPasswordMutationPayload';
  token?: Maybe<Scalars['String']>;
  newPassword: Scalars['String'];
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type ResetPasswordMutationInput = {
  token?: Maybe<Scalars['String']>;
  newPassword: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Obtain JSON web token and user information.
 *
 * Non-verified users can still login.
 */
export type LoginMutationPayload = {
  __typename?: 'LoginMutationPayload';
  user?: Maybe<UserObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type LoginMutationInput = {
  usernameOrEmail: Scalars['String'];
  password: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Delete JSON web token cookie and logout.
 *
 * This sets the `Set-Cookie` header so that the JWT token cookie gets automatically
 * deleted in frontend.
 */
export type LogoutMutation = {
  __typename?: 'LogoutMutation';
  deleted: Scalars['Boolean'];
};

/**
 * Change password with a requirement of knowing the old password.
 *
 * Only allowed for authenticated users.
 */
export type ChangePasswordMutationPayload = {
  __typename?: 'ChangePasswordMutationPayload';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type ChangePasswordMutationInput = {
  oldPassword: Scalars['String'];
  newPassword: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Update public profile fields for a user.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type UpdateProfileMutationPayload = {
  __typename?: 'UpdateProfileMutationPayload';
  user?: Maybe<UserObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type UpdateProfileMutationInput = {
  username: Scalars['String'];
  title?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  avatar?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Update private account settings for a user.
 *
 * Only allowed for authenticated users.
 */
export type UpdateAccountSettingsMutationPayload = {
  __typename?: 'UpdateAccountSettingsMutationPayload';
  user?: Maybe<UserObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type UpdateAccountSettingsMutationInput = {
  email: Scalars['String'];
  commentReplyEmailPermission?: Maybe<Scalars['Boolean']>;
  threadCommentEmailPermission?: Maybe<Scalars['Boolean']>;
  newBadgeEmailPermission?: Maybe<Scalars['Boolean']>;
  commentReplyPushPermission?: Maybe<Scalars['Boolean']>;
  threadCommentPushPermission?: Maybe<Scalars['Boolean']>;
  newBadgePushPermission?: Maybe<Scalars['Boolean']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Permanently delete the account.
 *
 * The user must confirm his password.
 *
 * Only allowed for authenticated users.
 */
export type DeleteUserMutationPayload = {
  __typename?: 'DeleteUserMutationPayload';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type DeleteUserMutationInput = {
  password: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Change the badge which progress the user currently tracks.
 *
 * Only allowed for authenticated users.
 */
export type UpdateSelectedBadgeMutationPayload = {
  __typename?: 'UpdateSelectedBadgeMutationPayload';
  badgeProgress?: Maybe<BadgeProgressObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type UpdateSelectedBadgeMutationInput = {
  id?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Register FCM token for a user.
 *
 * Only allowed for authenticated users.
 */
export type RegisterFcmTokenMutationPayload = {
  __typename?: 'RegisterFCMTokenMutationPayload';
  token?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type RegisterFcmTokenMutationInput = {
  token?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Email the user with a link to a zip file containing **all** of their data. */
export type MyDataMutation = {
  __typename?: 'MyDataMutation';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
};

/**
 * Create a new thread.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type CreateThreadMutationPayload = {
  __typename?: 'CreateThreadMutationPayload';
  thread?: Maybe<ThreadObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type CreateThreadMutationInput = {
  title: Scalars['String'];
  text?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  user?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Delete a thread.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type DeleteThreadMutationPayload = {
  __typename?: 'DeleteThreadMutationPayload';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type DeleteThreadMutationInput = {
  id?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Submit a message via the contact form. */
export type ContactMutationPayload = {
  __typename?: 'ContactMutationPayload';
  subject?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  message: Scalars['String'];
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type ContactMutationInput = {
  subject?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  message: Scalars['String'];
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Create a new comment.
 *
 * Attachments are popped of for unauthenticated users. The `user` field must match
 * with the ID of the user making the query to save the user making the query as the
 * author of the comment. This way even authenticated users can create anonymous
 * comments by setting the `user` field as `null`.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type CreateCommentMutationPayload = {
  __typename?: 'CreateCommentMutationPayload';
  comment?: Maybe<CommentObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type CreateCommentMutationInput = {
  user?: Maybe<Scalars['ID']>;
  text?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  thread?: Maybe<Scalars['ID']>;
  comment?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Update an existing comment.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type UpdateCommentMutationPayload = {
  __typename?: 'UpdateCommentMutationPayload';
  comment?: Maybe<CommentObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  successMessage?: Maybe<Scalars['String']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type UpdateCommentMutationInput = {
  text?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Delete a comment.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type DeleteCommentMutationPayload = {
  __typename?: 'DeleteCommentMutationPayload';
  successMessage?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type DeleteCommentMutationInput = {
  id?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Mark a single activity read/unread.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type MarkActivityAsReadMutationPayload = {
  __typename?: 'MarkActivityAsReadMutationPayload';
  activity?: Maybe<ActivityObjectType>;
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  clientMutationId?: Maybe<Scalars['String']>;
};

export type MarkActivityAsReadMutationInput = {
  read?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['ID']>;
  clientMutationId?: Maybe<Scalars['String']>;
};

/**
 * Mark all activities of the given user as read.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export type MarkAllActivitiesAsReadMutation = {
  __typename?: 'MarkAllActivitiesAsReadMutation';
  errors?: Maybe<Array<Maybe<ErrorType>>>;
  activities?: Maybe<PaginatedActivityObjectType>;
};

export type ActivityFieldsFragment = (
  { __typename?: 'ActivityObjectType' }
  & Pick<ActivityObjectType, 'id' | 'description' | 'read'>
  & { causingUser?: Maybe<(
    { __typename?: 'UserObjectType' }
    & Pick<UserObjectType, 'slug' | 'username' | 'avatarThumbnail'>
  )>, comment?: Maybe<(
    { __typename?: 'CommentObjectType' }
    & Pick<CommentObjectType, 'id'>
    & { thread?: Maybe<(
      { __typename?: 'ThreadObjectType' }
      & Pick<ThreadObjectType, 'slug'>
    )> }
  )>, badgeProgress?: Maybe<(
    { __typename?: 'BadgeProgressObjectType' }
    & { badge: (
      { __typename?: 'BadgeObjectType' }
      & Pick<BadgeObjectType, 'tier'>
    ) }
  )> }
);

export type PaginatedActivityFieldsFragment = (
  { __typename?: 'PaginatedActivityObjectType' }
  & Pick<PaginatedActivityObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'>
  & { objects?: Maybe<Array<Maybe<(
    { __typename?: 'ActivityObjectType' }
    & ActivityFieldsFragment
  )>>> }
);

export type ActivitiesQueryVariables = Exact<{
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
}>;


export type ActivitiesQuery = (
  { __typename?: 'Query' }
  & { activities?: Maybe<(
    { __typename?: 'PaginatedActivityObjectType' }
    & PaginatedActivityFieldsFragment
  )> }
);

export type ActivityPreviewQueryVariables = Exact<{ [key: string]: never; }>;


export type ActivityPreviewQuery = (
  { __typename?: 'Query' }
  & { activityPreview?: Maybe<Array<Maybe<(
    { __typename?: 'ActivityObjectType' }
    & ActivityFieldsFragment
  )>>> }
);

export type MarkActivityAsReadMutationVariables = Exact<{
  id?: Maybe<Scalars['ID']>;
  read?: Maybe<Scalars['Boolean']>;
}>;


export type MarkActivityAsReadMutation = (
  { __typename?: 'Mutation' }
  & { markActivityAsRead?: Maybe<(
    { __typename?: 'MarkActivityAsReadMutationPayload' }
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, activity?: Maybe<(
      { __typename?: 'ActivityObjectType' }
      & ActivityFieldsFragment
    )> }
  )> }
);

export type GraphQlMarkAllActivitiesAsReadMutationVariables = Exact<{ [key: string]: never; }>;


export type GraphQlMarkAllActivitiesAsReadMutation = (
  { __typename?: 'Mutation' }
  & { markAllActivitiesAsRead?: Maybe<(
    { __typename?: 'MarkAllActivitiesAsReadMutation' }
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, activities?: Maybe<(
      { __typename?: 'PaginatedActivityObjectType' }
      & PaginatedActivityFieldsFragment
    )> }
  )> }
);

export type CreateCommentMutationVariables = Exact<{
  user?: Maybe<Scalars['ID']>;
  text: Scalars['String'];
  image?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  thread?: Maybe<Scalars['ID']>;
  comment?: Maybe<Scalars['ID']>;
}>;


export type CreateCommentMutation = (
  { __typename?: 'Mutation' }
  & { createComment?: Maybe<(
    { __typename?: 'CreateCommentMutationPayload' }
    & Pick<CreateCommentMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, comment?: Maybe<(
      { __typename?: 'CommentObjectType' }
      & Pick<CommentObjectType, 'id'>
      & { thread?: Maybe<(
        { __typename?: 'ThreadObjectType' }
        & Pick<ThreadObjectType, 'slug'>
      )> }
    )> }
  )> }
);

export type DeleteCommentMutationVariables = Exact<{
  id?: Maybe<Scalars['ID']>;
}>;


export type DeleteCommentMutation = (
  { __typename?: 'Mutation' }
  & { deleteComment?: Maybe<(
    { __typename?: 'DeleteCommentMutationPayload' }
    & Pick<DeleteCommentMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type CreateContactMessageMutationVariables = Exact<{
  subject?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  message: Scalars['String'];
}>;


export type CreateContactMessageMutation = (
  { __typename?: 'Mutation' }
  & { createContactMessage?: Maybe<(
    { __typename?: 'ContactMutationPayload' }
    & Pick<ContactMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type ThreadFieldsFragment = (
  { __typename?: 'ThreadObjectType' }
  & Pick<ThreadObjectType, 'id' | 'slug' | 'title' | 'text' | 'image' | 'imageThumbnail' | 'modified' | 'created' | 'score' | 'starred' | 'starCount' | 'commentCount'>
  & { vote?: Maybe<(
    { __typename?: 'VoteObjectType' }
    & Pick<VoteObjectType, 'id' | 'status'>
  )>, user?: Maybe<(
    { __typename?: 'UserObjectType' }
    & Pick<UserObjectType, 'id' | 'slug' | 'username'>
  )> }
);

export type PaginatedThreadFieldsFragment = (
  { __typename?: 'PaginatedThreadObjectType' }
  & Pick<PaginatedThreadObjectType, 'page' | 'pages' | 'hasPrev' | 'hasNext' | 'count'>
  & { objects?: Maybe<Array<Maybe<(
    { __typename?: 'ThreadObjectType' }
    & ThreadFieldsFragment
  )>>> }
);

export type ThreadsQueryVariables = Exact<{
  searchTerm?: Maybe<Scalars['String']>;
  ordering?: Maybe<Scalars['String']>;
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
}>;


export type ThreadsQuery = (
  { __typename?: 'Query' }
  & { threads?: Maybe<(
    { __typename?: 'PaginatedThreadObjectType' }
    & PaginatedThreadFieldsFragment
  )> }
);

export type ThreadQueryVariables = Exact<{
  slug?: Maybe<Scalars['String']>;
}>;


export type ThreadQuery = (
  { __typename?: 'Query' }
  & { thread?: Maybe<(
    { __typename?: 'ThreadObjectType' }
    & ThreadFieldsFragment
  )> }
);

export type ThreadCommentsQueryVariables = Exact<{
  slug?: Maybe<Scalars['String']>;
  ordering?: Maybe<Scalars['String']>;
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
}>;


export type ThreadCommentsQuery = (
  { __typename?: 'Query' }
  & { comments?: Maybe<(
    { __typename?: 'PaginatedCommentObjectType' }
    & Pick<PaginatedCommentObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'>
    & { objects?: Maybe<Array<Maybe<(
      { __typename?: 'CommentObjectType' }
      & { replyComments: Array<(
        { __typename?: 'CommentObjectType' }
        & CommentFieldsFragment
      )> }
      & CommentFieldsFragment
    )>>> }
  )> }
);

export type CreateThreadMutationVariables = Exact<{
  title: Scalars['String'];
  text?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
}>;


export type CreateThreadMutation = (
  { __typename?: 'Mutation' }
  & { createThread?: Maybe<(
    { __typename?: 'CreateThreadMutationPayload' }
    & Pick<CreateThreadMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, thread?: Maybe<(
      { __typename?: 'ThreadObjectType' }
      & Pick<ThreadObjectType, 'slug'>
    )> }
  )> }
);

export type DeleteThreadMutationVariables = Exact<{
  id?: Maybe<Scalars['ID']>;
}>;


export type DeleteThreadMutation = (
  { __typename?: 'Mutation' }
  & { deleteThread?: Maybe<(
    { __typename?: 'DeleteThreadMutationPayload' }
    & Pick<DeleteThreadMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type StarredQueryVariables = Exact<{
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
}>;


export type StarredQuery = (
  { __typename?: 'Query' }
  & { starredThreads?: Maybe<(
    { __typename?: 'PaginatedThreadObjectType' }
    & PaginatedThreadFieldsFragment
  )> }
);

export type StarMutationVariables = Exact<{
  thread: Scalars['ID'];
}>;


export type StarMutation = (
  { __typename?: 'Mutation' }
  & { star?: Maybe<(
    { __typename?: 'StarMutationPayload' }
    & Pick<StarMutationPayload, 'starred'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type BadgeProgressFieldsFragment = (
  { __typename?: 'BadgeProgressObjectType' }
  & Pick<BadgeProgressObjectType, 'progress' | 'steps'>
  & { badge: (
    { __typename?: 'BadgeObjectType' }
    & Pick<BadgeObjectType, 'id' | 'name' | 'description' | 'tier'>
  ) }
);

export type UserMeFieldsFragment = (
  { __typename?: 'UserObjectType' }
  & Pick<UserObjectType, 'id' | 'slug' | 'username' | 'email' | 'title' | 'bio' | 'avatar' | 'avatarThumbnail' | 'score' | 'created' | 'verified' | 'unreadActivityCount' | 'fcmToken' | 'rank' | 'commentReplyEmailPermission' | 'threadCommentEmailPermission' | 'newBadgeEmailPermission' | 'commentReplyPushPermission' | 'threadCommentPushPermission' | 'newBadgePushPermission'>
  & { badgeProgresses?: Maybe<Array<Maybe<(
    { __typename?: 'BadgeProgressObjectType' }
    & BadgeProgressFieldsFragment
  )>>>, selectedBadgeProgress?: Maybe<(
    { __typename?: 'BadgeProgressObjectType' }
    & BadgeProgressFieldsFragment
  )> }
);

export type UserMeQueryVariables = Exact<{ [key: string]: never; }>;


export type UserMeQuery = (
  { __typename?: 'Query' }
  & { userMe?: Maybe<(
    { __typename?: 'UserObjectType' }
    & UserMeFieldsFragment
  )> }
);

export type CommentFieldsFragment = (
  { __typename?: 'CommentObjectType' }
  & Pick<CommentObjectType, 'id' | 'text' | 'image' | 'imageThumbnail' | 'file' | 'created' | 'score' | 'replyCount'>
  & { user?: Maybe<(
    { __typename?: 'UserObjectType' }
    & Pick<UserObjectType, 'id' | 'slug' | 'username' | 'avatarThumbnail'>
  )>, thread?: Maybe<(
    { __typename?: 'ThreadObjectType' }
    & Pick<ThreadObjectType, 'slug' | 'title'>
  )> }
);

export type UserQueryVariables = Exact<{
  slug?: Maybe<Scalars['String']>;
}>;


export type UserQuery = (
  { __typename?: 'Query' }
  & { user?: Maybe<(
    { __typename?: 'UserObjectType' }
    & Pick<UserObjectType, 'id' | 'username' | 'title' | 'bio' | 'avatar' | 'score' | 'created' | 'verified' | 'rank' | 'threadCount' | 'commentCount'>
    & { badges?: Maybe<Array<Maybe<(
      { __typename?: 'BadgeObjectType' }
      & Pick<BadgeObjectType, 'name' | 'description' | 'tier'>
    )>>> }
  )> }
);

export type UserThreadsQueryVariables = Exact<{
  slug?: Maybe<Scalars['String']>;
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
}>;


export type UserThreadsQuery = (
  { __typename?: 'Query' }
  & { threads?: Maybe<(
    { __typename?: 'PaginatedThreadObjectType' }
    & PaginatedThreadFieldsFragment
  )> }
);

export type UserCommentsQueryVariables = Exact<{
  slug?: Maybe<Scalars['String']>;
  page?: Maybe<Scalars['Int']>;
  pageSize?: Maybe<Scalars['Int']>;
}>;


export type UserCommentsQuery = (
  { __typename?: 'Query' }
  & { comments?: Maybe<(
    { __typename?: 'PaginatedCommentObjectType' }
    & Pick<PaginatedCommentObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'>
    & { objects?: Maybe<Array<Maybe<(
      { __typename?: 'CommentObjectType' }
      & { comment?: Maybe<(
        { __typename?: 'CommentObjectType' }
        & { thread?: Maybe<(
          { __typename?: 'ThreadObjectType' }
          & Pick<ThreadObjectType, 'slug' | 'title'>
        )> }
      )> }
      & CommentFieldsFragment
    )>>> }
  )> }
);

export type RegisterMutationVariables = Exact<{
  username: Scalars['String'];
  email: Scalars['String'];
  password: Scalars['String'];
}>;


export type RegisterMutation = (
  { __typename?: 'Mutation' }
  & { register?: Maybe<(
    { __typename?: 'RegisterMutationPayload' }
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )>, login?: Maybe<(
    { __typename?: 'LoginMutationPayload' }
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, user?: Maybe<(
      { __typename?: 'UserObjectType' }
      & UserMeFieldsFragment
    )> }
  )> }
);

export type LoginMutationVariables = Exact<{
  usernameOrEmail: Scalars['String'];
  password: Scalars['String'];
}>;


export type LoginMutation = (
  { __typename?: 'Mutation' }
  & { login?: Maybe<(
    { __typename?: 'LoginMutationPayload' }
    & Pick<LoginMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type GraphQlLogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type GraphQlLogoutMutation = (
  { __typename?: 'Mutation' }
  & { logout?: Maybe<(
    { __typename?: 'LogoutMutation' }
    & Pick<LogoutMutation, 'deleted'>
  )> }
);

export type GraphQlResendVerificationEmailMutationVariables = Exact<{ [key: string]: never; }>;


export type GraphQlResendVerificationEmailMutation = (
  { __typename?: 'Mutation' }
  & { resendVerificationEmail?: Maybe<(
    { __typename?: 'ResendVerificationEmailMutation' }
    & Pick<ResendVerificationEmailMutation, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type GraphQlMyDataMutationVariables = Exact<{ [key: string]: never; }>;


export type GraphQlMyDataMutation = (
  { __typename?: 'Mutation' }
  & { myData?: Maybe<(
    { __typename?: 'MyDataMutation' }
    & Pick<MyDataMutation, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type VerifyAccountMutationVariables = Exact<{
  token?: Maybe<Scalars['String']>;
}>;


export type VerifyAccountMutation = (
  { __typename?: 'Mutation' }
  & { verifyAccount?: Maybe<(
    { __typename?: 'VerifyAccountMutationPayload' }
    & Pick<VerifyAccountMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type SendPasswordResetEmailMutationVariables = Exact<{
  email: Scalars['String'];
}>;


export type SendPasswordResetEmailMutation = (
  { __typename?: 'Mutation' }
  & { sendPasswordResetEmail?: Maybe<(
    { __typename?: 'SendPasswordResetEmailMutationPayload' }
    & Pick<SendPasswordResetEmailMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type ResetPasswordMutationVariables = Exact<{
  token?: Maybe<Scalars['String']>;
  newPassword: Scalars['String'];
}>;


export type ResetPasswordMutation = (
  { __typename?: 'Mutation' }
  & { resetPassword?: Maybe<(
    { __typename?: 'ResetPasswordMutationPayload' }
    & Pick<ResetPasswordMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type UpdateProfileMutationVariables = Exact<{
  username: Scalars['String'];
  title?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  avatar?: Maybe<Scalars['String']>;
}>;


export type UpdateProfileMutation = (
  { __typename?: 'Mutation' }
  & { updateProfile?: Maybe<(
    { __typename?: 'UpdateProfileMutationPayload' }
    & Pick<UpdateProfileMutationPayload, 'successMessage'>
    & { user?: Maybe<(
      { __typename?: 'UserObjectType' }
      & UserMeFieldsFragment
    )>, errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type UpdateAccountSettingsMutationVariables = Exact<{
  email: Scalars['String'];
  commentReplyEmailPermission?: Maybe<Scalars['Boolean']>;
  threadCommentEmailPermission?: Maybe<Scalars['Boolean']>;
  newBadgeEmailPermission?: Maybe<Scalars['Boolean']>;
  commentReplyPushPermission?: Maybe<Scalars['Boolean']>;
  threadCommentPushPermission?: Maybe<Scalars['Boolean']>;
  newBadgePushPermission?: Maybe<Scalars['Boolean']>;
}>;


export type UpdateAccountSettingsMutation = (
  { __typename?: 'Mutation' }
  & { updateAccountSettings?: Maybe<(
    { __typename?: 'UpdateAccountSettingsMutationPayload' }
    & Pick<UpdateAccountSettingsMutationPayload, 'successMessage'>
    & { user?: Maybe<(
      { __typename?: 'UserObjectType' }
      & UserMeFieldsFragment
    )>, errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type ChangePasswordMutationVariables = Exact<{
  oldPassword: Scalars['String'];
  newPassword: Scalars['String'];
}>;


export type ChangePasswordMutation = (
  { __typename?: 'Mutation' }
  & { changePassword?: Maybe<(
    { __typename?: 'ChangePasswordMutationPayload' }
    & Pick<ChangePasswordMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type DeleteUserMutationVariables = Exact<{
  password: Scalars['String'];
}>;


export type DeleteUserMutation = (
  { __typename?: 'Mutation' }
  & { deleteUser?: Maybe<(
    { __typename?: 'DeleteUserMutationPayload' }
    & Pick<DeleteUserMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export type VoteMutationVariables = Exact<{
  status: Scalars['Int'];
  comment?: Maybe<Scalars['ID']>;
  thread?: Maybe<Scalars['ID']>;
}>;


export type VoteMutation = (
  { __typename?: 'Mutation' }
  & { vote?: Maybe<(
    { __typename?: 'VoteMutationPayload' }
    & Pick<VoteMutationPayload, 'targetScore'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, vote?: Maybe<(
      { __typename?: 'VoteObjectType' }
      & Pick<VoteObjectType, 'id' | 'status'>
    )> }
  )> }
);

export type UpdateSelectedBadgeMutationVariables = Exact<{
  id?: Maybe<Scalars['ID']>;
}>;


export type UpdateSelectedBadgeMutation = (
  { __typename?: 'Mutation' }
  & { updateSelectedBadge?: Maybe<(
    { __typename?: 'UpdateSelectedBadgeMutationPayload' }
    & Pick<UpdateSelectedBadgeMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>>, badgeProgress?: Maybe<(
      { __typename?: 'BadgeProgressObjectType' }
      & BadgeProgressFieldsFragment
    )> }
  )> }
);

export type BadgesQueryVariables = Exact<{ [key: string]: never; }>;


export type BadgesQuery = (
  { __typename?: 'Query' }
  & { badges?: Maybe<Array<Maybe<(
    { __typename?: 'BadgeObjectType' }
    & Pick<BadgeObjectType, 'name' | 'description' | 'tier'>
  )>>> }
);

export type RegisterFcmTokenMutationVariables = Exact<{
  token?: Maybe<Scalars['String']>;
}>;


export type RegisterFcmTokenMutation = (
  { __typename?: 'Mutation' }
  & { registerFcmToken?: Maybe<(
    { __typename?: 'RegisterFCMTokenMutationPayload' }
    & Pick<RegisterFcmTokenMutationPayload, 'successMessage'>
    & { errors?: Maybe<Array<Maybe<(
      { __typename?: 'ErrorType' }
      & Pick<ErrorType, 'field' | 'messages'>
    )>>> }
  )> }
);

export const ActivityFieldsFragmentDoc = gql`
    fragment activityFields on ActivityObjectType {
  id
  description
  read
  causingUser {
    slug
    username
    avatarThumbnail
  }
  comment {
    id
    thread {
      slug
    }
  }
  badgeProgress {
    badge {
      tier
    }
  }
}
    `;
export const PaginatedActivityFieldsFragmentDoc = gql`
    fragment paginatedActivityFields on PaginatedActivityObjectType {
  page
  pages
  hasNext
  hasPrev
  count
  objects {
    ...activityFields
  }
}
    ${ActivityFieldsFragmentDoc}`;
export const ThreadFieldsFragmentDoc = gql`
    fragment threadFields on ThreadObjectType {
  id
  slug
  title
  text
  image
  imageThumbnail
  modified
  created
  score
  starred
  starCount
  commentCount
  vote {
    id
    status
  }
  user {
    id
    slug
    username
  }
}
    `;
export const PaginatedThreadFieldsFragmentDoc = gql`
    fragment paginatedThreadFields on PaginatedThreadObjectType {
  page
  pages
  hasPrev
  hasNext
  count
  objects {
    ...threadFields
  }
}
    ${ThreadFieldsFragmentDoc}`;
export const BadgeProgressFieldsFragmentDoc = gql`
    fragment badgeProgressFields on BadgeProgressObjectType {
  badge {
    id
    name
    description
    tier
  }
  progress
  steps
}
    `;
export const UserMeFieldsFragmentDoc = gql`
    fragment userMeFields on UserObjectType {
  id
  slug
  username
  email
  title
  bio
  avatar
  avatarThumbnail
  score
  created
  verified
  unreadActivityCount
  fcmToken
  rank
  commentReplyEmailPermission
  threadCommentEmailPermission
  newBadgeEmailPermission
  commentReplyPushPermission
  threadCommentPushPermission
  newBadgePushPermission
  badgeProgresses {
    ...badgeProgressFields
  }
  selectedBadgeProgress {
    ...badgeProgressFields
  }
}
    ${BadgeProgressFieldsFragmentDoc}`;
export const CommentFieldsFragmentDoc = gql`
    fragment commentFields on CommentObjectType {
  id
  text
  image
  imageThumbnail
  file
  created
  score
  replyCount
  user {
    id
    slug
    username
    avatarThumbnail
  }
  thread {
    slug
    title
  }
}
    `;
export const ActivitiesDocument = gql`
    query Activities($page: Int, $pageSize: Int) {
  activities(page: $page, pageSize: $pageSize) {
    ...paginatedActivityFields
  }
}
    ${PaginatedActivityFieldsFragmentDoc}`;

/**
 * __useActivitiesQuery__
 *
 * To run a query within a React component, call `useActivitiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivitiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivitiesQuery({
 *   variables: {
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useActivitiesQuery(baseOptions?: Apollo.QueryHookOptions<ActivitiesQuery, ActivitiesQueryVariables>) {
        return Apollo.useQuery<ActivitiesQuery, ActivitiesQueryVariables>(ActivitiesDocument, baseOptions);
      }
export function useActivitiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivitiesQuery, ActivitiesQueryVariables>) {
          return Apollo.useLazyQuery<ActivitiesQuery, ActivitiesQueryVariables>(ActivitiesDocument, baseOptions);
        }
export type ActivitiesQueryHookResult = ReturnType<typeof useActivitiesQuery>;
export type ActivitiesLazyQueryHookResult = ReturnType<typeof useActivitiesLazyQuery>;
export type ActivitiesQueryResult = Apollo.QueryResult<ActivitiesQuery, ActivitiesQueryVariables>;
export const ActivityPreviewDocument = gql`
    query ActivityPreview {
  activityPreview {
    ...activityFields
  }
}
    ${ActivityFieldsFragmentDoc}`;

/**
 * __useActivityPreviewQuery__
 *
 * To run a query within a React component, call `useActivityPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivityPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivityPreviewQuery({
 *   variables: {
 *   },
 * });
 */
export function useActivityPreviewQuery(baseOptions?: Apollo.QueryHookOptions<ActivityPreviewQuery, ActivityPreviewQueryVariables>) {
        return Apollo.useQuery<ActivityPreviewQuery, ActivityPreviewQueryVariables>(ActivityPreviewDocument, baseOptions);
      }
export function useActivityPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivityPreviewQuery, ActivityPreviewQueryVariables>) {
          return Apollo.useLazyQuery<ActivityPreviewQuery, ActivityPreviewQueryVariables>(ActivityPreviewDocument, baseOptions);
        }
export type ActivityPreviewQueryHookResult = ReturnType<typeof useActivityPreviewQuery>;
export type ActivityPreviewLazyQueryHookResult = ReturnType<typeof useActivityPreviewLazyQuery>;
export type ActivityPreviewQueryResult = Apollo.QueryResult<ActivityPreviewQuery, ActivityPreviewQueryVariables>;
export const MarkActivityAsReadDocument = gql`
    mutation MarkActivityAsRead($id: ID, $read: Boolean) {
  markActivityAsRead(input: {id: $id, read: $read}) {
    errors {
      field
      messages
    }
    activity {
      ...activityFields
    }
  }
}
    ${ActivityFieldsFragmentDoc}`;
export type MarkActivityAsReadMutationFn = Apollo.MutationFunction<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>;

/**
 * __useMarkActivityAsReadMutation__
 *
 * To run a mutation, you first call `useMarkActivityAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMarkActivityAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [markActivityAsReadMutation, { data, loading, error }] = useMarkActivityAsReadMutation({
 *   variables: {
 *      id: // value for 'id'
 *      read: // value for 'read'
 *   },
 * });
 */
export function useMarkActivityAsReadMutation(baseOptions?: Apollo.MutationHookOptions<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>) {
        return Apollo.useMutation<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>(MarkActivityAsReadDocument, baseOptions);
      }
export type MarkActivityAsReadMutationHookResult = ReturnType<typeof useMarkActivityAsReadMutation>;
export type MarkActivityAsReadMutationResult = Apollo.MutationResult<MarkActivityAsReadMutation>;
export type MarkActivityAsReadMutationOptions = Apollo.BaseMutationOptions<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>;
export const GraphQlMarkAllActivitiesAsReadDocument = gql`
    mutation GraphQLMarkAllActivitiesAsRead {
  markAllActivitiesAsRead {
    errors {
      field
      messages
    }
    activities {
      ...paginatedActivityFields
    }
  }
}
    ${PaginatedActivityFieldsFragmentDoc}`;
export type GraphQlMarkAllActivitiesAsReadMutationFn = Apollo.MutationFunction<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>;

/**
 * __useGraphQlMarkAllActivitiesAsReadMutation__
 *
 * To run a mutation, you first call `useGraphQlMarkAllActivitiesAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlMarkAllActivitiesAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlMarkAllActivitiesAsReadMutation, { data, loading, error }] = useGraphQlMarkAllActivitiesAsReadMutation({
 *   variables: {
 *   },
 * });
 */
export function useGraphQlMarkAllActivitiesAsReadMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>) {
        return Apollo.useMutation<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>(GraphQlMarkAllActivitiesAsReadDocument, baseOptions);
      }
export type GraphQlMarkAllActivitiesAsReadMutationHookResult = ReturnType<typeof useGraphQlMarkAllActivitiesAsReadMutation>;
export type GraphQlMarkAllActivitiesAsReadMutationResult = Apollo.MutationResult<GraphQlMarkAllActivitiesAsReadMutation>;
export type GraphQlMarkAllActivitiesAsReadMutationOptions = Apollo.BaseMutationOptions<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>;
export const CreateCommentDocument = gql`
    mutation CreateComment($user: ID, $text: String!, $image: String, $file: String, $thread: ID, $comment: ID) {
  createComment(
    input: {user: $user, text: $text, image: $image, file: $file, thread: $thread, comment: $comment}
  ) {
    successMessage
    errors {
      field
      messages
    }
    comment {
      id
      thread {
        slug
      }
    }
  }
}
    `;
export type CreateCommentMutationFn = Apollo.MutationFunction<CreateCommentMutation, CreateCommentMutationVariables>;

/**
 * __useCreateCommentMutation__
 *
 * To run a mutation, you first call `useCreateCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentMutation, { data, loading, error }] = useCreateCommentMutation({
 *   variables: {
 *      user: // value for 'user'
 *      text: // value for 'text'
 *      image: // value for 'image'
 *      file: // value for 'file'
 *      thread: // value for 'thread'
 *      comment: // value for 'comment'
 *   },
 * });
 */
export function useCreateCommentMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentMutation, CreateCommentMutationVariables>) {
        return Apollo.useMutation<CreateCommentMutation, CreateCommentMutationVariables>(CreateCommentDocument, baseOptions);
      }
export type CreateCommentMutationHookResult = ReturnType<typeof useCreateCommentMutation>;
export type CreateCommentMutationResult = Apollo.MutationResult<CreateCommentMutation>;
export type CreateCommentMutationOptions = Apollo.BaseMutationOptions<CreateCommentMutation, CreateCommentMutationVariables>;
export const DeleteCommentDocument = gql`
    mutation DeleteComment($id: ID) {
  deleteComment(input: {id: $id}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type DeleteCommentMutationFn = Apollo.MutationFunction<DeleteCommentMutation, DeleteCommentMutationVariables>;

/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCommentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCommentMutation, DeleteCommentMutationVariables>) {
        return Apollo.useMutation<DeleteCommentMutation, DeleteCommentMutationVariables>(DeleteCommentDocument, baseOptions);
      }
export type DeleteCommentMutationHookResult = ReturnType<typeof useDeleteCommentMutation>;
export type DeleteCommentMutationResult = Apollo.MutationResult<DeleteCommentMutation>;
export type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<DeleteCommentMutation, DeleteCommentMutationVariables>;
export const CreateContactMessageDocument = gql`
    mutation CreateContactMessage($subject: String, $name: String, $email: String, $message: String!) {
  createContactMessage(
    input: {subject: $subject, name: $name, email: $email, message: $message}
  ) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type CreateContactMessageMutationFn = Apollo.MutationFunction<CreateContactMessageMutation, CreateContactMessageMutationVariables>;

/**
 * __useCreateContactMessageMutation__
 *
 * To run a mutation, you first call `useCreateContactMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateContactMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createContactMessageMutation, { data, loading, error }] = useCreateContactMessageMutation({
 *   variables: {
 *      subject: // value for 'subject'
 *      name: // value for 'name'
 *      email: // value for 'email'
 *      message: // value for 'message'
 *   },
 * });
 */
export function useCreateContactMessageMutation(baseOptions?: Apollo.MutationHookOptions<CreateContactMessageMutation, CreateContactMessageMutationVariables>) {
        return Apollo.useMutation<CreateContactMessageMutation, CreateContactMessageMutationVariables>(CreateContactMessageDocument, baseOptions);
      }
export type CreateContactMessageMutationHookResult = ReturnType<typeof useCreateContactMessageMutation>;
export type CreateContactMessageMutationResult = Apollo.MutationResult<CreateContactMessageMutation>;
export type CreateContactMessageMutationOptions = Apollo.BaseMutationOptions<CreateContactMessageMutation, CreateContactMessageMutationVariables>;
export const ThreadsDocument = gql`
    query Threads($searchTerm: String, $ordering: String, $page: Int, $pageSize: Int) {
  threads(
    searchTerm: $searchTerm
    ordering: $ordering
    page: $page
    pageSize: $pageSize
  ) {
    ...paginatedThreadFields
  }
}
    ${PaginatedThreadFieldsFragmentDoc}`;

/**
 * __useThreadsQuery__
 *
 * To run a query within a React component, call `useThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadsQuery({
 *   variables: {
 *      searchTerm: // value for 'searchTerm'
 *      ordering: // value for 'ordering'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useThreadsQuery(baseOptions?: Apollo.QueryHookOptions<ThreadsQuery, ThreadsQueryVariables>) {
        return Apollo.useQuery<ThreadsQuery, ThreadsQueryVariables>(ThreadsDocument, baseOptions);
      }
export function useThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadsQuery, ThreadsQueryVariables>) {
          return Apollo.useLazyQuery<ThreadsQuery, ThreadsQueryVariables>(ThreadsDocument, baseOptions);
        }
export type ThreadsQueryHookResult = ReturnType<typeof useThreadsQuery>;
export type ThreadsLazyQueryHookResult = ReturnType<typeof useThreadsLazyQuery>;
export type ThreadsQueryResult = Apollo.QueryResult<ThreadsQuery, ThreadsQueryVariables>;
export const ThreadDocument = gql`
    query Thread($slug: String) {
  thread(slug: $slug) {
    ...threadFields
  }
}
    ${ThreadFieldsFragmentDoc}`;

/**
 * __useThreadQuery__
 *
 * To run a query within a React component, call `useThreadQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useThreadQuery(baseOptions?: Apollo.QueryHookOptions<ThreadQuery, ThreadQueryVariables>) {
        return Apollo.useQuery<ThreadQuery, ThreadQueryVariables>(ThreadDocument, baseOptions);
      }
export function useThreadLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadQuery, ThreadQueryVariables>) {
          return Apollo.useLazyQuery<ThreadQuery, ThreadQueryVariables>(ThreadDocument, baseOptions);
        }
export type ThreadQueryHookResult = ReturnType<typeof useThreadQuery>;
export type ThreadLazyQueryHookResult = ReturnType<typeof useThreadLazyQuery>;
export type ThreadQueryResult = Apollo.QueryResult<ThreadQuery, ThreadQueryVariables>;
export const ThreadCommentsDocument = gql`
    query ThreadComments($slug: String, $ordering: String, $page: Int, $pageSize: Int) {
  comments(thread: $slug, ordering: $ordering, page: $page, pageSize: $pageSize) {
    page
    pages
    hasNext
    hasPrev
    count
    objects {
      ...commentFields
      replyComments {
        ...commentFields
      }
    }
  }
}
    ${CommentFieldsFragmentDoc}`;

/**
 * __useThreadCommentsQuery__
 *
 * To run a query within a React component, call `useThreadCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadCommentsQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      ordering: // value for 'ordering'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useThreadCommentsQuery(baseOptions?: Apollo.QueryHookOptions<ThreadCommentsQuery, ThreadCommentsQueryVariables>) {
        return Apollo.useQuery<ThreadCommentsQuery, ThreadCommentsQueryVariables>(ThreadCommentsDocument, baseOptions);
      }
export function useThreadCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadCommentsQuery, ThreadCommentsQueryVariables>) {
          return Apollo.useLazyQuery<ThreadCommentsQuery, ThreadCommentsQueryVariables>(ThreadCommentsDocument, baseOptions);
        }
export type ThreadCommentsQueryHookResult = ReturnType<typeof useThreadCommentsQuery>;
export type ThreadCommentsLazyQueryHookResult = ReturnType<typeof useThreadCommentsLazyQuery>;
export type ThreadCommentsQueryResult = Apollo.QueryResult<ThreadCommentsQuery, ThreadCommentsQueryVariables>;
export const CreateThreadDocument = gql`
    mutation CreateThread($title: String!, $text: String, $image: String) {
  createThread(input: {title: $title, text: $text, image: $image}) {
    successMessage
    errors {
      field
      messages
    }
    thread {
      slug
    }
  }
}
    `;
export type CreateThreadMutationFn = Apollo.MutationFunction<CreateThreadMutation, CreateThreadMutationVariables>;

/**
 * __useCreateThreadMutation__
 *
 * To run a mutation, you first call `useCreateThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createThreadMutation, { data, loading, error }] = useCreateThreadMutation({
 *   variables: {
 *      title: // value for 'title'
 *      text: // value for 'text'
 *      image: // value for 'image'
 *   },
 * });
 */
export function useCreateThreadMutation(baseOptions?: Apollo.MutationHookOptions<CreateThreadMutation, CreateThreadMutationVariables>) {
        return Apollo.useMutation<CreateThreadMutation, CreateThreadMutationVariables>(CreateThreadDocument, baseOptions);
      }
export type CreateThreadMutationHookResult = ReturnType<typeof useCreateThreadMutation>;
export type CreateThreadMutationResult = Apollo.MutationResult<CreateThreadMutation>;
export type CreateThreadMutationOptions = Apollo.BaseMutationOptions<CreateThreadMutation, CreateThreadMutationVariables>;
export const DeleteThreadDocument = gql`
    mutation DeleteThread($id: ID) {
  deleteThread(input: {id: $id}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type DeleteThreadMutationFn = Apollo.MutationFunction<DeleteThreadMutation, DeleteThreadMutationVariables>;

/**
 * __useDeleteThreadMutation__
 *
 * To run a mutation, you first call `useDeleteThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteThreadMutation, { data, loading, error }] = useDeleteThreadMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteThreadMutation(baseOptions?: Apollo.MutationHookOptions<DeleteThreadMutation, DeleteThreadMutationVariables>) {
        return Apollo.useMutation<DeleteThreadMutation, DeleteThreadMutationVariables>(DeleteThreadDocument, baseOptions);
      }
export type DeleteThreadMutationHookResult = ReturnType<typeof useDeleteThreadMutation>;
export type DeleteThreadMutationResult = Apollo.MutationResult<DeleteThreadMutation>;
export type DeleteThreadMutationOptions = Apollo.BaseMutationOptions<DeleteThreadMutation, DeleteThreadMutationVariables>;
export const StarredDocument = gql`
    query Starred($page: Int, $pageSize: Int) {
  starredThreads(page: $page, pageSize: $pageSize) {
    ...paginatedThreadFields
  }
}
    ${PaginatedThreadFieldsFragmentDoc}`;

/**
 * __useStarredQuery__
 *
 * To run a query within a React component, call `useStarredQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarredQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarredQuery({
 *   variables: {
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useStarredQuery(baseOptions?: Apollo.QueryHookOptions<StarredQuery, StarredQueryVariables>) {
        return Apollo.useQuery<StarredQuery, StarredQueryVariables>(StarredDocument, baseOptions);
      }
export function useStarredLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarredQuery, StarredQueryVariables>) {
          return Apollo.useLazyQuery<StarredQuery, StarredQueryVariables>(StarredDocument, baseOptions);
        }
export type StarredQueryHookResult = ReturnType<typeof useStarredQuery>;
export type StarredLazyQueryHookResult = ReturnType<typeof useStarredLazyQuery>;
export type StarredQueryResult = Apollo.QueryResult<StarredQuery, StarredQueryVariables>;
export const StarDocument = gql`
    mutation Star($thread: ID!) {
  star(input: {thread: $thread}) {
    starred
    errors {
      field
      messages
    }
  }
}
    `;
export type StarMutationFn = Apollo.MutationFunction<StarMutation, StarMutationVariables>;

/**
 * __useStarMutation__
 *
 * To run a mutation, you first call `useStarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [starMutation, { data, loading, error }] = useStarMutation({
 *   variables: {
 *      thread: // value for 'thread'
 *   },
 * });
 */
export function useStarMutation(baseOptions?: Apollo.MutationHookOptions<StarMutation, StarMutationVariables>) {
        return Apollo.useMutation<StarMutation, StarMutationVariables>(StarDocument, baseOptions);
      }
export type StarMutationHookResult = ReturnType<typeof useStarMutation>;
export type StarMutationResult = Apollo.MutationResult<StarMutation>;
export type StarMutationOptions = Apollo.BaseMutationOptions<StarMutation, StarMutationVariables>;
export const UserMeDocument = gql`
    query UserMe {
  userMe {
    ...userMeFields
  }
}
    ${UserMeFieldsFragmentDoc}`;

/**
 * __useUserMeQuery__
 *
 * To run a query within a React component, call `useUserMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useUserMeQuery(baseOptions?: Apollo.QueryHookOptions<UserMeQuery, UserMeQueryVariables>) {
        return Apollo.useQuery<UserMeQuery, UserMeQueryVariables>(UserMeDocument, baseOptions);
      }
export function useUserMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserMeQuery, UserMeQueryVariables>) {
          return Apollo.useLazyQuery<UserMeQuery, UserMeQueryVariables>(UserMeDocument, baseOptions);
        }
export type UserMeQueryHookResult = ReturnType<typeof useUserMeQuery>;
export type UserMeLazyQueryHookResult = ReturnType<typeof useUserMeLazyQuery>;
export type UserMeQueryResult = Apollo.QueryResult<UserMeQuery, UserMeQueryVariables>;
export const UserDocument = gql`
    query User($slug: String) {
  user(slug: $slug) {
    id
    username
    title
    bio
    avatar
    score
    created
    verified
    rank
    threadCount
    commentCount
    badges {
      name
      description
      tier
    }
  }
}
    `;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useUserQuery(baseOptions?: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>) {
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, baseOptions);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export const UserThreadsDocument = gql`
    query UserThreads($slug: String, $page: Int, $pageSize: Int) {
  threads(user: $slug, page: $page, pageSize: $pageSize) {
    ...paginatedThreadFields
  }
}
    ${PaginatedThreadFieldsFragmentDoc}`;

/**
 * __useUserThreadsQuery__
 *
 * To run a query within a React component, call `useUserThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserThreadsQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useUserThreadsQuery(baseOptions?: Apollo.QueryHookOptions<UserThreadsQuery, UserThreadsQueryVariables>) {
        return Apollo.useQuery<UserThreadsQuery, UserThreadsQueryVariables>(UserThreadsDocument, baseOptions);
      }
export function useUserThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserThreadsQuery, UserThreadsQueryVariables>) {
          return Apollo.useLazyQuery<UserThreadsQuery, UserThreadsQueryVariables>(UserThreadsDocument, baseOptions);
        }
export type UserThreadsQueryHookResult = ReturnType<typeof useUserThreadsQuery>;
export type UserThreadsLazyQueryHookResult = ReturnType<typeof useUserThreadsLazyQuery>;
export type UserThreadsQueryResult = Apollo.QueryResult<UserThreadsQuery, UserThreadsQueryVariables>;
export const UserCommentsDocument = gql`
    query UserComments($slug: String, $page: Int, $pageSize: Int) {
  comments(user: $slug, page: $page, pageSize: $pageSize) {
    page
    pages
    hasNext
    hasPrev
    count
    objects {
      ...commentFields
      comment {
        thread {
          slug
          title
        }
      }
    }
  }
}
    ${CommentFieldsFragmentDoc}`;

/**
 * __useUserCommentsQuery__
 *
 * To run a query within a React component, call `useUserCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserCommentsQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export function useUserCommentsQuery(baseOptions?: Apollo.QueryHookOptions<UserCommentsQuery, UserCommentsQueryVariables>) {
        return Apollo.useQuery<UserCommentsQuery, UserCommentsQueryVariables>(UserCommentsDocument, baseOptions);
      }
export function useUserCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserCommentsQuery, UserCommentsQueryVariables>) {
          return Apollo.useLazyQuery<UserCommentsQuery, UserCommentsQueryVariables>(UserCommentsDocument, baseOptions);
        }
export type UserCommentsQueryHookResult = ReturnType<typeof useUserCommentsQuery>;
export type UserCommentsLazyQueryHookResult = ReturnType<typeof useUserCommentsLazyQuery>;
export type UserCommentsQueryResult = Apollo.QueryResult<UserCommentsQuery, UserCommentsQueryVariables>;
export const RegisterDocument = gql`
    mutation Register($username: String!, $email: String!, $password: String!) {
  register(input: {username: $username, email: $email, password: $password}) {
    errors {
      field
      messages
    }
  }
  login(input: {usernameOrEmail: $username, password: $password}) {
    errors {
      field
      messages
    }
    user {
      ...userMeFields
    }
  }
}
    ${UserMeFieldsFragmentDoc}`;
export type RegisterMutationFn = Apollo.MutationFunction<RegisterMutation, RegisterMutationVariables>;

/**
 * __useRegisterMutation__
 *
 * To run a mutation, you first call `useRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerMutation, { data, loading, error }] = useRegisterMutation({
 *   variables: {
 *      username: // value for 'username'
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useRegisterMutation(baseOptions?: Apollo.MutationHookOptions<RegisterMutation, RegisterMutationVariables>) {
        return Apollo.useMutation<RegisterMutation, RegisterMutationVariables>(RegisterDocument, baseOptions);
      }
export type RegisterMutationHookResult = ReturnType<typeof useRegisterMutation>;
export type RegisterMutationResult = Apollo.MutationResult<RegisterMutation>;
export type RegisterMutationOptions = Apollo.BaseMutationOptions<RegisterMutation, RegisterMutationVariables>;
export const LoginDocument = gql`
    mutation Login($usernameOrEmail: String!, $password: String!) {
  login(input: {usernameOrEmail: $usernameOrEmail, password: $password}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      usernameOrEmail: // value for 'usernameOrEmail'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, baseOptions);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const GraphQlLogoutDocument = gql`
    mutation GraphQLLogout {
  logout {
    deleted
  }
}
    `;
export type GraphQlLogoutMutationFn = Apollo.MutationFunction<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>;

/**
 * __useGraphQlLogoutMutation__
 *
 * To run a mutation, you first call `useGraphQlLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlLogoutMutation, { data, loading, error }] = useGraphQlLogoutMutation({
 *   variables: {
 *   },
 * });
 */
export function useGraphQlLogoutMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>) {
        return Apollo.useMutation<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>(GraphQlLogoutDocument, baseOptions);
      }
export type GraphQlLogoutMutationHookResult = ReturnType<typeof useGraphQlLogoutMutation>;
export type GraphQlLogoutMutationResult = Apollo.MutationResult<GraphQlLogoutMutation>;
export type GraphQlLogoutMutationOptions = Apollo.BaseMutationOptions<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>;
export const GraphQlResendVerificationEmailDocument = gql`
    mutation GraphQLResendVerificationEmail {
  resendVerificationEmail {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type GraphQlResendVerificationEmailMutationFn = Apollo.MutationFunction<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>;

/**
 * __useGraphQlResendVerificationEmailMutation__
 *
 * To run a mutation, you first call `useGraphQlResendVerificationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlResendVerificationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlResendVerificationEmailMutation, { data, loading, error }] = useGraphQlResendVerificationEmailMutation({
 *   variables: {
 *   },
 * });
 */
export function useGraphQlResendVerificationEmailMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>) {
        return Apollo.useMutation<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>(GraphQlResendVerificationEmailDocument, baseOptions);
      }
export type GraphQlResendVerificationEmailMutationHookResult = ReturnType<typeof useGraphQlResendVerificationEmailMutation>;
export type GraphQlResendVerificationEmailMutationResult = Apollo.MutationResult<GraphQlResendVerificationEmailMutation>;
export type GraphQlResendVerificationEmailMutationOptions = Apollo.BaseMutationOptions<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>;
export const GraphQlMyDataDocument = gql`
    mutation GraphQLMyData {
  myData {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type GraphQlMyDataMutationFn = Apollo.MutationFunction<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>;

/**
 * __useGraphQlMyDataMutation__
 *
 * To run a mutation, you first call `useGraphQlMyDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlMyDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlMyDataMutation, { data, loading, error }] = useGraphQlMyDataMutation({
 *   variables: {
 *   },
 * });
 */
export function useGraphQlMyDataMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>) {
        return Apollo.useMutation<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>(GraphQlMyDataDocument, baseOptions);
      }
export type GraphQlMyDataMutationHookResult = ReturnType<typeof useGraphQlMyDataMutation>;
export type GraphQlMyDataMutationResult = Apollo.MutationResult<GraphQlMyDataMutation>;
export type GraphQlMyDataMutationOptions = Apollo.BaseMutationOptions<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>;
export const VerifyAccountDocument = gql`
    mutation VerifyAccount($token: String) {
  verifyAccount(input: {token: $token}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type VerifyAccountMutationFn = Apollo.MutationFunction<VerifyAccountMutation, VerifyAccountMutationVariables>;

/**
 * __useVerifyAccountMutation__
 *
 * To run a mutation, you first call `useVerifyAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyAccountMutation, { data, loading, error }] = useVerifyAccountMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useVerifyAccountMutation(baseOptions?: Apollo.MutationHookOptions<VerifyAccountMutation, VerifyAccountMutationVariables>) {
        return Apollo.useMutation<VerifyAccountMutation, VerifyAccountMutationVariables>(VerifyAccountDocument, baseOptions);
      }
export type VerifyAccountMutationHookResult = ReturnType<typeof useVerifyAccountMutation>;
export type VerifyAccountMutationResult = Apollo.MutationResult<VerifyAccountMutation>;
export type VerifyAccountMutationOptions = Apollo.BaseMutationOptions<VerifyAccountMutation, VerifyAccountMutationVariables>;
export const SendPasswordResetEmailDocument = gql`
    mutation SendPasswordResetEmail($email: String!) {
  sendPasswordResetEmail(input: {email: $email}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type SendPasswordResetEmailMutationFn = Apollo.MutationFunction<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>;

/**
 * __useSendPasswordResetEmailMutation__
 *
 * To run a mutation, you first call `useSendPasswordResetEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendPasswordResetEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendPasswordResetEmailMutation, { data, loading, error }] = useSendPasswordResetEmailMutation({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export function useSendPasswordResetEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>) {
        return Apollo.useMutation<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>(SendPasswordResetEmailDocument, baseOptions);
      }
export type SendPasswordResetEmailMutationHookResult = ReturnType<typeof useSendPasswordResetEmailMutation>;
export type SendPasswordResetEmailMutationResult = Apollo.MutationResult<SendPasswordResetEmailMutation>;
export type SendPasswordResetEmailMutationOptions = Apollo.BaseMutationOptions<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>;
export const ResetPasswordDocument = gql`
    mutation ResetPassword($token: String, $newPassword: String!) {
  resetPassword(input: {token: $token, newPassword: $newPassword}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;

/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      token: // value for 'token'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>) {
        return Apollo.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, baseOptions);
      }
export type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const UpdateProfileDocument = gql`
    mutation UpdateProfile($username: String!, $title: String, $bio: String, $avatar: String) {
  updateProfile(
    input: {username: $username, title: $title, bio: $bio, avatar: $avatar}
  ) {
    successMessage
    user {
      ...userMeFields
    }
    errors {
      field
      messages
    }
  }
}
    ${UserMeFieldsFragmentDoc}`;
export type UpdateProfileMutationFn = Apollo.MutationFunction<UpdateProfileMutation, UpdateProfileMutationVariables>;

/**
 * __useUpdateProfileMutation__
 *
 * To run a mutation, you first call `useUpdateProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProfileMutation, { data, loading, error }] = useUpdateProfileMutation({
 *   variables: {
 *      username: // value for 'username'
 *      title: // value for 'title'
 *      bio: // value for 'bio'
 *      avatar: // value for 'avatar'
 *   },
 * });
 */
export function useUpdateProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProfileMutation, UpdateProfileMutationVariables>) {
        return Apollo.useMutation<UpdateProfileMutation, UpdateProfileMutationVariables>(UpdateProfileDocument, baseOptions);
      }
export type UpdateProfileMutationHookResult = ReturnType<typeof useUpdateProfileMutation>;
export type UpdateProfileMutationResult = Apollo.MutationResult<UpdateProfileMutation>;
export type UpdateProfileMutationOptions = Apollo.BaseMutationOptions<UpdateProfileMutation, UpdateProfileMutationVariables>;
export const UpdateAccountSettingsDocument = gql`
    mutation UpdateAccountSettings($email: String!, $commentReplyEmailPermission: Boolean, $threadCommentEmailPermission: Boolean, $newBadgeEmailPermission: Boolean, $commentReplyPushPermission: Boolean, $threadCommentPushPermission: Boolean, $newBadgePushPermission: Boolean) {
  updateAccountSettings(
    input: {email: $email, commentReplyEmailPermission: $commentReplyEmailPermission, threadCommentEmailPermission: $threadCommentEmailPermission, newBadgeEmailPermission: $newBadgeEmailPermission, commentReplyPushPermission: $commentReplyPushPermission, threadCommentPushPermission: $threadCommentPushPermission, newBadgePushPermission: $newBadgePushPermission}
  ) {
    successMessage
    user {
      ...userMeFields
    }
    errors {
      field
      messages
    }
  }
}
    ${UserMeFieldsFragmentDoc}`;
export type UpdateAccountSettingsMutationFn = Apollo.MutationFunction<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>;

/**
 * __useUpdateAccountSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateAccountSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAccountSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAccountSettingsMutation, { data, loading, error }] = useUpdateAccountSettingsMutation({
 *   variables: {
 *      email: // value for 'email'
 *      commentReplyEmailPermission: // value for 'commentReplyEmailPermission'
 *      threadCommentEmailPermission: // value for 'threadCommentEmailPermission'
 *      newBadgeEmailPermission: // value for 'newBadgeEmailPermission'
 *      commentReplyPushPermission: // value for 'commentReplyPushPermission'
 *      threadCommentPushPermission: // value for 'threadCommentPushPermission'
 *      newBadgePushPermission: // value for 'newBadgePushPermission'
 *   },
 * });
 */
export function useUpdateAccountSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>) {
        return Apollo.useMutation<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>(UpdateAccountSettingsDocument, baseOptions);
      }
export type UpdateAccountSettingsMutationHookResult = ReturnType<typeof useUpdateAccountSettingsMutation>;
export type UpdateAccountSettingsMutationResult = Apollo.MutationResult<UpdateAccountSettingsMutation>;
export type UpdateAccountSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>;
export const ChangePasswordDocument = gql`
    mutation ChangePassword($oldPassword: String!, $newPassword: String!) {
  changePassword(input: {oldPassword: $oldPassword, newPassword: $newPassword}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type ChangePasswordMutationFn = Apollo.MutationFunction<ChangePasswordMutation, ChangePasswordMutationVariables>;

/**
 * __useChangePasswordMutation__
 *
 * To run a mutation, you first call `useChangePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changePasswordMutation, { data, loading, error }] = useChangePasswordMutation({
 *   variables: {
 *      oldPassword: // value for 'oldPassword'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export function useChangePasswordMutation(baseOptions?: Apollo.MutationHookOptions<ChangePasswordMutation, ChangePasswordMutationVariables>) {
        return Apollo.useMutation<ChangePasswordMutation, ChangePasswordMutationVariables>(ChangePasswordDocument, baseOptions);
      }
export type ChangePasswordMutationHookResult = ReturnType<typeof useChangePasswordMutation>;
export type ChangePasswordMutationResult = Apollo.MutationResult<ChangePasswordMutation>;
export type ChangePasswordMutationOptions = Apollo.BaseMutationOptions<ChangePasswordMutation, ChangePasswordMutationVariables>;
export const DeleteUserDocument = gql`
    mutation DeleteUser($password: String!) {
  deleteUser(input: {password: $password}) {
    successMessage
    errors {
      field
      messages
    }
  }
}
    `;
export type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      password: // value for 'password'
 *   },
 * });
 */
export function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>) {
        return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, baseOptions);
      }
export type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export const VoteDocument = gql`
    mutation Vote($status: Int!, $comment: ID, $thread: ID) {
  vote(input: {status: $status, comment: $comment, thread: $thread}) {
    errors {
      field
      messages
    }
    targetScore
    vote {
      id
      status
    }
  }
}
    `;
export type VoteMutationFn = Apollo.MutationFunction<VoteMutation, VoteMutationVariables>;

/**
 * __useVoteMutation__
 *
 * To run a mutation, you first call `useVoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voteMutation, { data, loading, error }] = useVoteMutation({
 *   variables: {
 *      status: // value for 'status'
 *      comment: // value for 'comment'
 *      thread: // value for 'thread'
 *   },
 * });
 */
export function useVoteMutation(baseOptions?: Apollo.MutationHookOptions<VoteMutation, VoteMutationVariables>) {
        return Apollo.useMutation<VoteMutation, VoteMutationVariables>(VoteDocument, baseOptions);
      }
export type VoteMutationHookResult = ReturnType<typeof useVoteMutation>;
export type VoteMutationResult = Apollo.MutationResult<VoteMutation>;
export type VoteMutationOptions = Apollo.BaseMutationOptions<VoteMutation, VoteMutationVariables>;
export const UpdateSelectedBadgeDocument = gql`
    mutation UpdateSelectedBadge($id: ID) {
  updateSelectedBadge(input: {id: $id}) {
    errors {
      field
      messages
    }
    successMessage
    badgeProgress {
      ...badgeProgressFields
    }
  }
}
    ${BadgeProgressFieldsFragmentDoc}`;
export type UpdateSelectedBadgeMutationFn = Apollo.MutationFunction<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>;

/**
 * __useUpdateSelectedBadgeMutation__
 *
 * To run a mutation, you first call `useUpdateSelectedBadgeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSelectedBadgeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSelectedBadgeMutation, { data, loading, error }] = useUpdateSelectedBadgeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUpdateSelectedBadgeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>) {
        return Apollo.useMutation<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>(UpdateSelectedBadgeDocument, baseOptions);
      }
export type UpdateSelectedBadgeMutationHookResult = ReturnType<typeof useUpdateSelectedBadgeMutation>;
export type UpdateSelectedBadgeMutationResult = Apollo.MutationResult<UpdateSelectedBadgeMutation>;
export type UpdateSelectedBadgeMutationOptions = Apollo.BaseMutationOptions<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>;
export const BadgesDocument = gql`
    query Badges {
  badges {
    name
    description
    tier
  }
}
    `;

/**
 * __useBadgesQuery__
 *
 * To run a query within a React component, call `useBadgesQuery` and pass it any options that fit your needs.
 * When your component renders, `useBadgesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBadgesQuery({
 *   variables: {
 *   },
 * });
 */
export function useBadgesQuery(baseOptions?: Apollo.QueryHookOptions<BadgesQuery, BadgesQueryVariables>) {
        return Apollo.useQuery<BadgesQuery, BadgesQueryVariables>(BadgesDocument, baseOptions);
      }
export function useBadgesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BadgesQuery, BadgesQueryVariables>) {
          return Apollo.useLazyQuery<BadgesQuery, BadgesQueryVariables>(BadgesDocument, baseOptions);
        }
export type BadgesQueryHookResult = ReturnType<typeof useBadgesQuery>;
export type BadgesLazyQueryHookResult = ReturnType<typeof useBadgesLazyQuery>;
export type BadgesQueryResult = Apollo.QueryResult<BadgesQuery, BadgesQueryVariables>;
export const RegisterFcmTokenDocument = gql`
    mutation RegisterFCMToken($token: String) {
  registerFcmToken(input: {token: $token}) {
    errors {
      field
      messages
    }
    successMessage
  }
}
    `;
export type RegisterFcmTokenMutationFn = Apollo.MutationFunction<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>;

/**
 * __useRegisterFcmTokenMutation__
 *
 * To run a mutation, you first call `useRegisterFcmTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterFcmTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerFcmTokenMutation, { data, loading, error }] = useRegisterFcmTokenMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export function useRegisterFcmTokenMutation(baseOptions?: Apollo.MutationHookOptions<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>) {
        return Apollo.useMutation<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>(RegisterFcmTokenDocument, baseOptions);
      }
export type RegisterFcmTokenMutationHookResult = ReturnType<typeof useRegisterFcmTokenMutation>;
export type RegisterFcmTokenMutationResult = Apollo.MutationResult<RegisterFcmTokenMutation>;
export type RegisterFcmTokenMutationOptions = Apollo.BaseMutationOptions<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>;