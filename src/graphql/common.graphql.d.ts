/* ebc372eacc005367ea87784a3f2560ecec06d131
 * This file is automatically generated by graphql-let. */

import * as Apollo from '@apollo/client';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /**
     * The `DateTime` scalar type represents a DateTime
     * value as specified by
     * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
     */
    DateTime: any;
    /**
     * The `Date` scalar type represents a Date
     * value as specified by
     * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
     */
    Date: any;
};
export declare type Query = {
    __typename?: 'Query';
    badges?: Maybe<Array<Maybe<BadgeObjectType>>>;
    /**
     * Return comments filtered by query params.
     *
     * The `search_term` is used to search from comment creator usernames and comment text.
     *
     * Results are sorted by creation time.
     *
     * Only allowed for authenticated users that have verified their accounts.
     *
     * Results are paginated.
     */
    comments?: Maybe<PaginatedCommentObjectType>;
    /**
     * Return user profile of the user making the query.
     *
     * Only allowed for authenticated users.
     */
    userMe?: Maybe<UserObjectType>;
    /** Superusers or users who haven't entered an invite code cannot be queried. */
    user?: Maybe<UserObjectType>;
    /**
     * Return the dynamic page slugs that frontend needs to build a
     * `sitemap.xml`.
     */
    sitemap?: Maybe<SitemapObjectType>;
    /**
     * Return threads filtered by query params.
     *
     * The `search_term` is used to search from thread title and text.
     *
     * Results are sorted either manually based on query params or by secret Skole AI-
     * powered algorithms. If the `user` argument is passed the results will always
     * just be sorted by creation time.
     *
     * Only allowed for authenticated users that have verified their accounts.
     *
     * Results are paginated.
     */
    threads?: Maybe<PaginatedThreadObjectType>;
    /**
     * Return starred threads of the user making the query.
     *
     * Results are sorted by creation time. Return an empty list for unauthenticated
     * users.
     *
     * Only allowed for authenticated users that have verified their accounts.
     *
     * Results are paginated.
     */
    starredThreads?: Maybe<PaginatedThreadObjectType>;
    thread?: Maybe<ThreadObjectType>;
    /**
     * Return all activity of to the user making the query.
     *
     * Results are sorted by creation time.
     *
     * Only allowed for authenticated users that have verified their accounts.
     *
     * Results are paginated.
     */
    activities?: Maybe<PaginatedActivityObjectType>;
    /**
     * Return limited amount of activity of user making the query for a preview.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    activityPreview?: Maybe<Array<Maybe<ActivityObjectType>>>;
};
export declare type QueryCommentsArgs = {
    user?: Maybe<Scalars['String']>;
    thread?: Maybe<Scalars['String']>;
    ordering?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryUserArgs = {
    slug?: Maybe<Scalars['String']>;
};
export declare type QueryThreadsArgs = {
    searchTerm?: Maybe<Scalars['String']>;
    user?: Maybe<Scalars['String']>;
    ordering?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryStarredThreadsArgs = {
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryThreadArgs = {
    slug?: Maybe<Scalars['String']>;
};
export declare type QueryActivitiesArgs = {
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
/** Models a badge awarded for a user, e.g `Moderator`. */
export declare type BadgeObjectType = {
    __typename?: 'BadgeObjectType';
    id: Scalars['ID'];
    tier: BadgeTier;
    name: Scalars['String'];
    description: Scalars['String'];
};
/** An enumeration. */
export declare enum BadgeTier {
    /** Diamond */
    Diamond = "DIAMOND",
    /** Gold */
    Gold = "GOLD",
    /** Silver */
    Silver = "SILVER",
    /** Bronze */
    Bronze = "BRONZE"
}
/**
 * Models one comment posted on a comment thread.
 *
 * Results are paginated.
 */
export declare type PaginatedCommentObjectType = {
    __typename?: 'PaginatedCommentObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<CommentObjectType>>>;
};
export declare type CommentObjectType = {
    __typename?: 'CommentObjectType';
    id: Scalars['ID'];
    user?: Maybe<UserObjectType>;
    text: Scalars['String'];
    file: Scalars['String'];
    image: Scalars['String'];
    thread?: Maybe<ThreadObjectType>;
    comment?: Maybe<CommentObjectType>;
    modified: Scalars['DateTime'];
    created: Scalars['DateTime'];
    replyComments: Array<CommentObjectType>;
    score?: Maybe<Scalars['Int']>;
    vote?: Maybe<VoteObjectType>;
    replyCount?: Maybe<Scalars['Int']>;
    imageThumbnail?: Maybe<Scalars['String']>;
    isOwn: Scalars['Boolean'];
};
/**
 * Models one user on the platform.
 *
 * The following fields are private, meaning they are returned only if the user is
 * querying one's own profile: `email`, `backup_email`, `verified`, `badge_progresses`,
 * `selected_badge_progress`, `invite_code`, and all `permission` fields.
 *
 * For instances that are not the user's own user profile, these fields will return a
 * `null` value.
 */
export declare type UserObjectType = {
    __typename?: 'UserObjectType';
    id: Scalars['ID'];
    slug?: Maybe<Scalars['String']>;
    username: Scalars['String'];
    email?: Maybe<Scalars['String']>;
    backupEmail?: Maybe<Scalars['String']>;
    title: Scalars['String'];
    bio: Scalars['String'];
    avatar: Scalars['String'];
    selectedBadgeProgress?: Maybe<BadgeProgressObjectType>;
    score: Scalars['Int'];
    verified?: Maybe<Scalars['Boolean']>;
    created: Scalars['DateTime'];
    modified: Scalars['DateTime'];
    commentReplyEmailPermission?: Maybe<Scalars['Boolean']>;
    threadCommentEmailPermission?: Maybe<Scalars['Boolean']>;
    newBadgeEmailPermission?: Maybe<Scalars['Boolean']>;
    commentReplyPushPermission?: Maybe<Scalars['Boolean']>;
    threadCommentPushPermission?: Maybe<Scalars['Boolean']>;
    newBadgePushPermission?: Maybe<Scalars['Boolean']>;
    badgeProgresses?: Maybe<Array<Maybe<BadgeProgressObjectType>>>;
    inviteCode?: Maybe<InviteCodeObjectType>;
    threadCount?: Maybe<Scalars['Int']>;
    commentCount?: Maybe<Scalars['Int']>;
    avatarThumbnail?: Maybe<Scalars['String']>;
    rank?: Maybe<Scalars['String']>;
    badges?: Maybe<Array<Maybe<BadgeObjectType>>>;
    unreadActivityCount?: Maybe<Scalars['Int']>;
    fcmToken?: Maybe<Scalars['String']>;
};
/**
 * Models the progress of a user's single badge.
 *
 * E.g. User testuser2 can have a progress of 5/15 comments to get a 'Commenter' badge.
 */
export declare type BadgeProgressObjectType = {
    __typename?: 'BadgeProgressObjectType';
    badge: BadgeObjectType;
    user: UserObjectType;
    progress: Scalars['Int'];
    steps?: Maybe<Scalars['Int']>;
};
/** Models one invite code that a user can use to invite new users. */
export declare type InviteCodeObjectType = {
    __typename?: 'InviteCodeObjectType';
    code: Scalars['String'];
    usages: Scalars['Int'];
};
export declare type ThreadObjectType = {
    __typename?: 'ThreadObjectType';
    id: Scalars['ID'];
    title: Scalars['String'];
    text: Scalars['String'];
    slug?: Maybe<Scalars['String']>;
    image: Scalars['String'];
    user?: Maybe<UserObjectType>;
    modified: Scalars['DateTime'];
    created: Scalars['DateTime'];
    starred?: Maybe<Scalars['Boolean']>;
    score?: Maybe<Scalars['Int']>;
    vote?: Maybe<VoteObjectType>;
    starCount?: Maybe<Scalars['Int']>;
    commentCount?: Maybe<Scalars['Int']>;
    imageThumbnail?: Maybe<Scalars['String']>;
};
/** Models one vote on either a comment or a thread. */
export declare type VoteObjectType = {
    __typename?: 'VoteObjectType';
    id: Scalars['ID'];
    user?: Maybe<UserObjectType>;
    status?: Maybe<Scalars['Int']>;
    comment?: Maybe<CommentObjectType>;
    thread?: Maybe<ThreadObjectType>;
};
export declare type SitemapObjectType = {
    __typename?: 'SitemapObjectType';
    threads: Array<SitemapEntryObjectType>;
    users: Array<SitemapEntryObjectType>;
};
export declare type SitemapEntryObjectType = {
    __typename?: 'SitemapEntryObjectType';
    slug?: Maybe<Scalars['String']>;
    modified?: Maybe<Scalars['Date']>;
};
/**
 * Models one thread.
 *
 * Results are paginated.
 */
export declare type PaginatedThreadObjectType = {
    __typename?: 'PaginatedThreadObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<ThreadObjectType>>>;
};
/**
 * Models a single activity of a users activity feed.
 *
 * Results are paginated.
 */
export declare type PaginatedActivityObjectType = {
    __typename?: 'PaginatedActivityObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<ActivityObjectType>>>;
};
/** Models a single activity of a users activity feed. */
export declare type ActivityObjectType = {
    __typename?: 'ActivityObjectType';
    id: Scalars['ID'];
    causingUser?: Maybe<UserObjectType>;
    comment?: Maybe<CommentObjectType>;
    badgeProgress?: Maybe<BadgeProgressObjectType>;
    read?: Maybe<Scalars['Boolean']>;
    description?: Maybe<Scalars['String']>;
};
export declare type Mutation = {
    __typename?: 'Mutation';
    /**
     * Start a thread or remove the star if it already exists.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    star?: Maybe<StarMutationPayload>;
    /**
     * Upvote, downvote or remove a vote from a thread or a comment.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    vote?: Maybe<VoteMutationPayload>;
    /**
     * Register a new user.
     *
     * Check if there is an existing user with that email or username. Check that account
     * is not deactivated. By default, set the user's account as unverified. After
     * successful registration, the user is allowed to use an invite code.
     */
    register?: Maybe<RegisterMutationPayload>;
    /**
     * Receive the token that was sent by email.
     *
     * If the token is valid, verify the user's account.
     */
    verifyAccount?: Maybe<VerifyAccountMutationPayload>;
    /**
     * Use an invite code and make the user fully registered.
     *
     * After successfully entering the invite code, send account verification email.
     */
    useInviteCode?: Maybe<UseInviteCodeMutationPayload>;
    /**
     * Send the verification email again.
     *
     * Return an error in the following cases:
     * - A user account with the provided email address was not found.
     * - An unknown error while sending the email occurred.
     * - The user has already verified one's account.
     */
    resendVerificationEmail?: Maybe<ResendVerificationEmailMutation>;
    /**
     * Send password reset email.
     *
     * Return an error in the following cases:
     * - A user account with the provided email address was not found.
     * - An unknown error while sending the email occurred.
     */
    sendPasswordResetEmail?: Maybe<SendPasswordResetEmailMutationPayload>;
    /**
     * Change user's password without knowing the old password.
     *
     * Receive the token that was sent by email. Revoke refresh token and require the user
     * to log in again with one's new password.
     */
    resetPassword?: Maybe<ResetPasswordMutationPayload>;
    /**
     * Obtain JSON web token and user information.
     *
     * Non-verified users can still login.
     */
    login?: Maybe<LoginMutationPayload>;
    /**
     * Delete JSON web token cookie and logout.
     *
     * This sets the `Set-Cookie` header so that the JWT token cookie gets automatically
     * deleted in frontend.
     */
    logout?: Maybe<LogoutMutation>;
    /**
     * Change password with a requirement of knowing the old password.
     *
     * Only allowed for authenticated users.
     */
    changePassword?: Maybe<ChangePasswordMutationPayload>;
    /**
     * Update public profile fields for a user.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    updateProfile?: Maybe<UpdateProfileMutationPayload>;
    /**
     * Update private account settings for a user.
     *
     * Only allowed for authenticated users.
     */
    updateAccountSettings?: Maybe<UpdateAccountSettingsMutationPayload>;
    /**
     * Permanently delete the account.
     *
     * The user must confirm his password.
     *
     * Only allowed for authenticated users.
     */
    deleteUser?: Maybe<DeleteUserMutationPayload>;
    /**
     * Change the badge which progress the user currently tracks.
     *
     * Only allowed for authenticated users.
     */
    updateSelectedBadge?: Maybe<UpdateSelectedBadgeMutationPayload>;
    /**
     * Register FCM token for a user.
     *
     * Only allowed for authenticated users.
     */
    registerFcmToken?: Maybe<RegisterFcmTokenMutationPayload>;
    /** Email the user with a link to a zip file containing **all** of their data. */
    myData?: Maybe<MyDataMutation>;
    /**
     * Create a new thread.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    createThread?: Maybe<CreateThreadMutationPayload>;
    /**
     * Delete a thread.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    deleteThread?: Maybe<DeleteThreadMutationPayload>;
    /** Submit a message via the contact form. */
    createContactMessage?: Maybe<ContactMutationPayload>;
    /**
     * Create a new comment.
     *
     * Attachments are popped of for unauthenticated users. The `user` field must match
     * with the ID of the user making the query to save the user making the query as the
     * author of the comment. This way even authenticated users can create anonymous
     * comments by setting the `user` field as `null`.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    createComment?: Maybe<CreateCommentMutationPayload>;
    /**
     * Update an existing comment.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    updateComment?: Maybe<UpdateCommentMutationPayload>;
    /**
     * Delete a comment.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    deleteComment?: Maybe<DeleteCommentMutationPayload>;
    /**
     * Mark a single activity read/unread.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    markActivityAsRead?: Maybe<MarkActivityAsReadMutationPayload>;
    /**
     * Mark all activities of the given user as read.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    markAllActivitiesAsRead?: Maybe<MarkAllActivitiesAsReadMutation>;
};
export declare type MutationStarArgs = {
    input: StarMutationInput;
};
export declare type MutationVoteArgs = {
    input: VoteMutationInput;
};
export declare type MutationRegisterArgs = {
    input: RegisterMutationInput;
};
export declare type MutationVerifyAccountArgs = {
    input: VerifyAccountMutationInput;
};
export declare type MutationUseInviteCodeArgs = {
    input: UseInviteCodeMutationInput;
};
export declare type MutationSendPasswordResetEmailArgs = {
    input: SendPasswordResetEmailMutationInput;
};
export declare type MutationResetPasswordArgs = {
    input: ResetPasswordMutationInput;
};
export declare type MutationLoginArgs = {
    input: LoginMutationInput;
};
export declare type MutationChangePasswordArgs = {
    input: ChangePasswordMutationInput;
};
export declare type MutationUpdateProfileArgs = {
    input: UpdateProfileMutationInput;
};
export declare type MutationUpdateAccountSettingsArgs = {
    input: UpdateAccountSettingsMutationInput;
};
export declare type MutationDeleteUserArgs = {
    input: DeleteUserMutationInput;
};
export declare type MutationUpdateSelectedBadgeArgs = {
    input: UpdateSelectedBadgeMutationInput;
};
export declare type MutationRegisterFcmTokenArgs = {
    input: RegisterFcmTokenMutationInput;
};
export declare type MutationCreateThreadArgs = {
    input: CreateThreadMutationInput;
};
export declare type MutationDeleteThreadArgs = {
    input: DeleteThreadMutationInput;
};
export declare type MutationCreateContactMessageArgs = {
    input: ContactMutationInput;
};
export declare type MutationCreateCommentArgs = {
    input: CreateCommentMutationInput;
};
export declare type MutationUpdateCommentArgs = {
    input: UpdateCommentMutationInput;
};
export declare type MutationDeleteCommentArgs = {
    input: DeleteCommentMutationInput;
};
export declare type MutationMarkActivityAsReadArgs = {
    input: MarkActivityAsReadMutationInput;
};
/**
 * Start a thread or remove the star if it already exists.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type StarMutationPayload = {
    __typename?: 'StarMutationPayload';
    star?: Maybe<StarObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    starred?: Maybe<Scalars['Boolean']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/** Models a star that a user has placed on a thread. */
export declare type StarObjectType = {
    __typename?: 'StarObjectType';
    id: Scalars['ID'];
    user: UserObjectType;
    thread: ThreadObjectType;
};
export declare type ErrorType = {
    __typename?: 'ErrorType';
    field: Scalars['String'];
    messages: Array<Scalars['String']>;
};
export declare type StarMutationInput = {
    thread: Scalars['ID'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Upvote, downvote or remove a vote from a thread or a comment.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type VoteMutationPayload = {
    __typename?: 'VoteMutationPayload';
    vote?: Maybe<VoteObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    targetScore?: Maybe<Scalars['Int']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type VoteMutationInput = {
    status: Scalars['Int'];
    comment?: Maybe<Scalars['ID']>;
    thread?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Register a new user.
 *
 * Check if there is an existing user with that email or username. Check that account
 * is not deactivated. By default, set the user's account as unverified. After
 * successful registration, the user is allowed to use an invite code.
 */
export declare type RegisterMutationPayload = {
    __typename?: 'RegisterMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type RegisterMutationInput = {
    username: Scalars['String'];
    email: Scalars['String'];
    password: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Receive the token that was sent by email.
 *
 * If the token is valid, verify the user's account.
 */
export declare type VerifyAccountMutationPayload = {
    __typename?: 'VerifyAccountMutationPayload';
    token?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type VerifyAccountMutationInput = {
    token?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Use an invite code and make the user fully registered.
 *
 * After successfully entering the invite code, send account verification email.
 */
export declare type UseInviteCodeMutationPayload = {
    __typename?: 'UseInviteCodeMutationPayload';
    usernameOrEmail: Scalars['String'];
    code: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UseInviteCodeMutationInput = {
    usernameOrEmail: Scalars['String'];
    code: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Send the verification email again.
 *
 * Return an error in the following cases:
 * - A user account with the provided email address was not found.
 * - An unknown error while sending the email occurred.
 * - The user has already verified one's account.
 */
export declare type ResendVerificationEmailMutation = {
    __typename?: 'ResendVerificationEmailMutation';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
};
/**
 * Send password reset email.
 *
 * Return an error in the following cases:
 * - A user account with the provided email address was not found.
 * - An unknown error while sending the email occurred.
 */
export declare type SendPasswordResetEmailMutationPayload = {
    __typename?: 'SendPasswordResetEmailMutationPayload';
    email: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type SendPasswordResetEmailMutationInput = {
    email: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Change user's password without knowing the old password.
 *
 * Receive the token that was sent by email. Revoke refresh token and require the user
 * to log in again with one's new password.
 */
export declare type ResetPasswordMutationPayload = {
    __typename?: 'ResetPasswordMutationPayload';
    token?: Maybe<Scalars['String']>;
    newPassword: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type ResetPasswordMutationInput = {
    token?: Maybe<Scalars['String']>;
    newPassword: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Obtain JSON web token and user information.
 *
 * Non-verified users can still login.
 */
export declare type LoginMutationPayload = {
    __typename?: 'LoginMutationPayload';
    user?: Maybe<UserObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    inviteCodeRequired?: Maybe<Scalars['Boolean']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type LoginMutationInput = {
    usernameOrEmail: Scalars['String'];
    password: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete JSON web token cookie and logout.
 *
 * This sets the `Set-Cookie` header so that the JWT token cookie gets automatically
 * deleted in frontend.
 */
export declare type LogoutMutation = {
    __typename?: 'LogoutMutation';
    deleted: Scalars['Boolean'];
};
/**
 * Change password with a requirement of knowing the old password.
 *
 * Only allowed for authenticated users.
 */
export declare type ChangePasswordMutationPayload = {
    __typename?: 'ChangePasswordMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type ChangePasswordMutationInput = {
    oldPassword: Scalars['String'];
    newPassword: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Update public profile fields for a user.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type UpdateProfileMutationPayload = {
    __typename?: 'UpdateProfileMutationPayload';
    user?: Maybe<UserObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateProfileMutationInput = {
    username: Scalars['String'];
    title?: Maybe<Scalars['String']>;
    bio?: Maybe<Scalars['String']>;
    avatar?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Update private account settings for a user.
 *
 * Only allowed for authenticated users.
 */
export declare type UpdateAccountSettingsMutationPayload = {
    __typename?: 'UpdateAccountSettingsMutationPayload';
    user?: Maybe<UserObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateAccountSettingsMutationInput = {
    email: Scalars['String'];
    backupEmail?: Maybe<Scalars['String']>;
    commentReplyEmailPermission?: Maybe<Scalars['Boolean']>;
    threadCommentEmailPermission?: Maybe<Scalars['Boolean']>;
    newBadgeEmailPermission?: Maybe<Scalars['Boolean']>;
    commentReplyPushPermission?: Maybe<Scalars['Boolean']>;
    threadCommentPushPermission?: Maybe<Scalars['Boolean']>;
    newBadgePushPermission?: Maybe<Scalars['Boolean']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Permanently delete the account.
 *
 * The user must confirm his password.
 *
 * Only allowed for authenticated users.
 */
export declare type DeleteUserMutationPayload = {
    __typename?: 'DeleteUserMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteUserMutationInput = {
    password: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Change the badge which progress the user currently tracks.
 *
 * Only allowed for authenticated users.
 */
export declare type UpdateSelectedBadgeMutationPayload = {
    __typename?: 'UpdateSelectedBadgeMutationPayload';
    badgeProgress?: Maybe<BadgeProgressObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateSelectedBadgeMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Register FCM token for a user.
 *
 * Only allowed for authenticated users.
 */
export declare type RegisterFcmTokenMutationPayload = {
    __typename?: 'RegisterFCMTokenMutationPayload';
    token?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type RegisterFcmTokenMutationInput = {
    token?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/** Email the user with a link to a zip file containing **all** of their data. */
export declare type MyDataMutation = {
    __typename?: 'MyDataMutation';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
};
/**
 * Create a new thread.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type CreateThreadMutationPayload = {
    __typename?: 'CreateThreadMutationPayload';
    thread?: Maybe<ThreadObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type CreateThreadMutationInput = {
    title: Scalars['String'];
    text?: Maybe<Scalars['String']>;
    image?: Maybe<Scalars['String']>;
    user?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete a thread.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type DeleteThreadMutationPayload = {
    __typename?: 'DeleteThreadMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteThreadMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/** Submit a message via the contact form. */
export declare type ContactMutationPayload = {
    __typename?: 'ContactMutationPayload';
    subject?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
    message: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type ContactMutationInput = {
    subject?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
    message: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Create a new comment.
 *
 * Attachments are popped of for unauthenticated users. The `user` field must match
 * with the ID of the user making the query to save the user making the query as the
 * author of the comment. This way even authenticated users can create anonymous
 * comments by setting the `user` field as `null`.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type CreateCommentMutationPayload = {
    __typename?: 'CreateCommentMutationPayload';
    comment?: Maybe<CommentObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type CreateCommentMutationInput = {
    user?: Maybe<Scalars['ID']>;
    text?: Maybe<Scalars['String']>;
    file?: Maybe<Scalars['String']>;
    image?: Maybe<Scalars['String']>;
    thread?: Maybe<Scalars['ID']>;
    comment?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Update an existing comment.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type UpdateCommentMutationPayload = {
    __typename?: 'UpdateCommentMutationPayload';
    comment?: Maybe<CommentObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateCommentMutationInput = {
    text?: Maybe<Scalars['String']>;
    file?: Maybe<Scalars['String']>;
    image?: Maybe<Scalars['String']>;
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete a comment.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type DeleteCommentMutationPayload = {
    __typename?: 'DeleteCommentMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteCommentMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Mark a single activity read/unread.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type MarkActivityAsReadMutationPayload = {
    __typename?: 'MarkActivityAsReadMutationPayload';
    activity?: Maybe<ActivityObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type MarkActivityAsReadMutationInput = {
    read?: Maybe<Scalars['Boolean']>;
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Mark all activities of the given user as read.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type MarkAllActivitiesAsReadMutation = {
    __typename?: 'MarkAllActivitiesAsReadMutation';
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    activities?: Maybe<PaginatedActivityObjectType>;
};
export declare type ActivityFieldsFragment = ({
    __typename?: 'ActivityObjectType';
} & Pick<ActivityObjectType, 'id' | 'description' | 'read'> & {
    causingUser?: Maybe<({
        __typename?: 'UserObjectType';
    } & Pick<UserObjectType, 'slug' | 'username' | 'avatarThumbnail'>)>;
    comment?: Maybe<({
        __typename?: 'CommentObjectType';
    } & Pick<CommentObjectType, 'id'> & {
        thread?: Maybe<({
            __typename?: 'ThreadObjectType';
        } & Pick<ThreadObjectType, 'slug'>)>;
    })>;
    badgeProgress?: Maybe<({
        __typename?: 'BadgeProgressObjectType';
    } & {
        badge: ({
            __typename?: 'BadgeObjectType';
        } & Pick<BadgeObjectType, 'tier'>);
    })>;
});
export declare type PaginatedActivityFieldsFragment = ({
    __typename?: 'PaginatedActivityObjectType';
} & Pick<PaginatedActivityObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
    objects?: Maybe<Array<Maybe<({
        __typename?: 'ActivityObjectType';
    } & ActivityFieldsFragment)>>>;
});
export declare type ActivitiesQueryVariables = Exact<{
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type ActivitiesQuery = ({
    __typename?: 'Query';
} & {
    activities?: Maybe<({
        __typename?: 'PaginatedActivityObjectType';
    } & PaginatedActivityFieldsFragment)>;
});
export declare type ActivityPreviewQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type ActivityPreviewQuery = ({
    __typename?: 'Query';
} & {
    activityPreview?: Maybe<Array<Maybe<({
        __typename?: 'ActivityObjectType';
    } & ActivityFieldsFragment)>>>;
});
export declare type MarkActivityAsReadMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
    read?: Maybe<Scalars['Boolean']>;
}>;
export declare type MarkActivityAsReadMutation = ({
    __typename?: 'Mutation';
} & {
    markActivityAsRead?: Maybe<({
        __typename?: 'MarkActivityAsReadMutationPayload';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        activity?: Maybe<({
            __typename?: 'ActivityObjectType';
        } & ActivityFieldsFragment)>;
    })>;
});
export declare type GraphQlMarkAllActivitiesAsReadMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlMarkAllActivitiesAsReadMutation = ({
    __typename?: 'Mutation';
} & {
    markAllActivitiesAsRead?: Maybe<({
        __typename?: 'MarkAllActivitiesAsReadMutation';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        activities?: Maybe<({
            __typename?: 'PaginatedActivityObjectType';
        } & PaginatedActivityFieldsFragment)>;
    })>;
});
export declare type CreateCommentMutationVariables = Exact<{
    user?: Maybe<Scalars['ID']>;
    text: Scalars['String'];
    image?: Maybe<Scalars['String']>;
    file?: Maybe<Scalars['String']>;
    thread?: Maybe<Scalars['ID']>;
    comment?: Maybe<Scalars['ID']>;
}>;
export declare type CreateCommentMutation = ({
    __typename?: 'Mutation';
} & {
    createComment?: Maybe<({
        __typename?: 'CreateCommentMutationPayload';
    } & Pick<CreateCommentMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        comment?: Maybe<({
            __typename?: 'CommentObjectType';
        } & Pick<CommentObjectType, 'id'> & {
            thread?: Maybe<({
                __typename?: 'ThreadObjectType';
            } & Pick<ThreadObjectType, 'slug'>)>;
        })>;
    })>;
});
export declare type DeleteCommentMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type DeleteCommentMutation = ({
    __typename?: 'Mutation';
} & {
    deleteComment?: Maybe<({
        __typename?: 'DeleteCommentMutationPayload';
    } & Pick<DeleteCommentMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type CreateContactMessageMutationVariables = Exact<{
    subject?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
    message: Scalars['String'];
}>;
export declare type CreateContactMessageMutation = ({
    __typename?: 'Mutation';
} & {
    createContactMessage?: Maybe<({
        __typename?: 'ContactMutationPayload';
    } & Pick<ContactMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type ThreadFieldsFragment = ({
    __typename?: 'ThreadObjectType';
} & Pick<ThreadObjectType, 'id' | 'slug' | 'title' | 'text' | 'image' | 'imageThumbnail' | 'score' | 'starred' | 'starCount' | 'commentCount' | 'created' | 'modified'> & {
    vote?: Maybe<({
        __typename?: 'VoteObjectType';
    } & Pick<VoteObjectType, 'id' | 'status'>)>;
    user?: Maybe<({
        __typename?: 'UserObjectType';
    } & Pick<UserObjectType, 'id' | 'slug' | 'username'>)>;
});
export declare type PaginatedThreadFieldsFragment = ({
    __typename?: 'PaginatedThreadObjectType';
} & Pick<PaginatedThreadObjectType, 'page' | 'pages' | 'hasPrev' | 'hasNext' | 'count'> & {
    objects?: Maybe<Array<Maybe<({
        __typename?: 'ThreadObjectType';
    } & ThreadFieldsFragment)>>>;
});
export declare type ThreadsQueryVariables = Exact<{
    searchTerm?: Maybe<Scalars['String']>;
    ordering?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type ThreadsQuery = ({
    __typename?: 'Query';
} & {
    threads?: Maybe<({
        __typename?: 'PaginatedThreadObjectType';
    } & PaginatedThreadFieldsFragment)>;
});
export declare type ThreadQueryVariables = Exact<{
    slug?: Maybe<Scalars['String']>;
}>;
export declare type ThreadQuery = ({
    __typename?: 'Query';
} & {
    thread?: Maybe<({
        __typename?: 'ThreadObjectType';
    } & ThreadFieldsFragment)>;
});
export declare type ThreadCommentsQueryVariables = Exact<{
    slug?: Maybe<Scalars['String']>;
    ordering?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type ThreadCommentsQuery = ({
    __typename?: 'Query';
} & {
    comments?: Maybe<({
        __typename?: 'PaginatedCommentObjectType';
    } & Pick<PaginatedCommentObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CommentObjectType';
        } & {
            replyComments: Array<({
                __typename?: 'CommentObjectType';
            } & CommentFieldsFragment)>;
        } & CommentFieldsFragment)>>>;
    })>;
});
export declare type CreateThreadMutationVariables = Exact<{
    title: Scalars['String'];
    text?: Maybe<Scalars['String']>;
    image?: Maybe<Scalars['String']>;
}>;
export declare type CreateThreadMutation = ({
    __typename?: 'Mutation';
} & {
    createThread?: Maybe<({
        __typename?: 'CreateThreadMutationPayload';
    } & Pick<CreateThreadMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        thread?: Maybe<({
            __typename?: 'ThreadObjectType';
        } & Pick<ThreadObjectType, 'slug'>)>;
    })>;
});
export declare type DeleteThreadMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type DeleteThreadMutation = ({
    __typename?: 'Mutation';
} & {
    deleteThread?: Maybe<({
        __typename?: 'DeleteThreadMutationPayload';
    } & Pick<DeleteThreadMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type StarredQueryVariables = Exact<{
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type StarredQuery = ({
    __typename?: 'Query';
} & {
    starredThreads?: Maybe<({
        __typename?: 'PaginatedThreadObjectType';
    } & PaginatedThreadFieldsFragment)>;
});
export declare type StarMutationVariables = Exact<{
    thread: Scalars['ID'];
}>;
export declare type StarMutation = ({
    __typename?: 'Mutation';
} & {
    star?: Maybe<({
        __typename?: 'StarMutationPayload';
    } & Pick<StarMutationPayload, 'starred'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type BadgeFieldsFragment = ({
    __typename?: 'BadgeObjectType';
} & Pick<BadgeObjectType, 'id' | 'name' | 'description' | 'tier'>);
export declare type BadgeProgressFieldsFragment = ({
    __typename?: 'BadgeProgressObjectType';
} & Pick<BadgeProgressObjectType, 'progress' | 'steps'> & {
    badge: ({
        __typename?: 'BadgeObjectType';
    } & BadgeFieldsFragment);
});
export declare type UserFieldsFragment = ({
    __typename?: 'UserObjectType';
} & Pick<UserObjectType, 'id' | 'slug' | 'username' | 'email' | 'backupEmail' | 'title' | 'bio' | 'avatar' | 'avatarThumbnail' | 'score' | 'rank' | 'verified' | 'unreadActivityCount' | 'threadCount' | 'commentCount' | 'created' | 'modified' | 'fcmToken' | 'commentReplyEmailPermission' | 'threadCommentEmailPermission' | 'newBadgeEmailPermission' | 'commentReplyPushPermission' | 'threadCommentPushPermission' | 'newBadgePushPermission'> & {
    badges?: Maybe<Array<Maybe<({
        __typename?: 'BadgeObjectType';
    } & BadgeFieldsFragment)>>>;
    badgeProgresses?: Maybe<Array<Maybe<({
        __typename?: 'BadgeProgressObjectType';
    } & BadgeProgressFieldsFragment)>>>;
    selectedBadgeProgress?: Maybe<({
        __typename?: 'BadgeProgressObjectType';
    } & BadgeProgressFieldsFragment)>;
    inviteCode?: Maybe<({
        __typename?: 'InviteCodeObjectType';
    } & Pick<InviteCodeObjectType, 'code' | 'usages'>)>;
});
export declare type UserMeQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserMeQuery = ({
    __typename?: 'Query';
} & {
    userMe?: Maybe<({
        __typename?: 'UserObjectType';
    } & UserFieldsFragment)>;
});
export declare type _CommentFieldsFragment = ({
    __typename?: 'CommentObjectType';
} & Pick<CommentObjectType, 'id' | 'text' | 'image' | 'imageThumbnail' | 'file' | 'score' | 'replyCount' | 'isOwn' | 'created' | 'modified'> & {
    user?: Maybe<({
        __typename?: 'UserObjectType';
    } & Pick<UserObjectType, 'id' | 'slug' | 'username' | 'avatarThumbnail'>)>;
    thread?: Maybe<({
        __typename?: 'ThreadObjectType';
    } & Pick<ThreadObjectType, 'slug' | 'title'>)>;
    vote?: Maybe<({
        __typename?: 'VoteObjectType';
    } & Pick<VoteObjectType, 'id' | 'status'>)>;
});
export declare type CommentFieldsFragment = ({
    __typename?: 'CommentObjectType';
} & {
    comment?: Maybe<({
        __typename?: 'CommentObjectType';
    } & _CommentFieldsFragment)>;
} & _CommentFieldsFragment);
export declare type UserQueryVariables = Exact<{
    slug?: Maybe<Scalars['String']>;
}>;
export declare type UserQuery = ({
    __typename?: 'Query';
} & {
    user?: Maybe<({
        __typename?: 'UserObjectType';
    } & UserFieldsFragment)>;
});
export declare type UserThreadsQueryVariables = Exact<{
    slug?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type UserThreadsQuery = ({
    __typename?: 'Query';
} & {
    threads?: Maybe<({
        __typename?: 'PaginatedThreadObjectType';
    } & PaginatedThreadFieldsFragment)>;
});
export declare type UserCommentsQueryVariables = Exact<{
    slug?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type UserCommentsQuery = ({
    __typename?: 'Query';
} & {
    comments?: Maybe<({
        __typename?: 'PaginatedCommentObjectType';
    } & Pick<PaginatedCommentObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CommentObjectType';
        } & CommentFieldsFragment)>>>;
    })>;
});
export declare type RegisterMutationVariables = Exact<{
    username: Scalars['String'];
    email: Scalars['String'];
    password: Scalars['String'];
}>;
export declare type RegisterMutation = ({
    __typename?: 'Mutation';
} & {
    register?: Maybe<({
        __typename?: 'RegisterMutationPayload';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type LoginMutationVariables = Exact<{
    usernameOrEmail: Scalars['String'];
    password: Scalars['String'];
}>;
export declare type LoginMutation = ({
    __typename?: 'Mutation';
} & {
    login?: Maybe<({
        __typename?: 'LoginMutationPayload';
    } & Pick<LoginMutationPayload, 'successMessage' | 'inviteCodeRequired'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type GraphQlLogoutMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlLogoutMutation = ({
    __typename?: 'Mutation';
} & {
    logout?: Maybe<({
        __typename?: 'LogoutMutation';
    } & Pick<LogoutMutation, 'deleted'>)>;
});
export declare type GraphQlResendVerificationEmailMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlResendVerificationEmailMutation = ({
    __typename?: 'Mutation';
} & {
    resendVerificationEmail?: Maybe<({
        __typename?: 'ResendVerificationEmailMutation';
    } & Pick<ResendVerificationEmailMutation, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type GraphQlMyDataMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlMyDataMutation = ({
    __typename?: 'Mutation';
} & {
    myData?: Maybe<({
        __typename?: 'MyDataMutation';
    } & Pick<MyDataMutation, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type VerifyAccountMutationVariables = Exact<{
    token?: Maybe<Scalars['String']>;
}>;
export declare type VerifyAccountMutation = ({
    __typename?: 'Mutation';
} & {
    verifyAccount?: Maybe<({
        __typename?: 'VerifyAccountMutationPayload';
    } & Pick<VerifyAccountMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type SendPasswordResetEmailMutationVariables = Exact<{
    email: Scalars['String'];
}>;
export declare type SendPasswordResetEmailMutation = ({
    __typename?: 'Mutation';
} & {
    sendPasswordResetEmail?: Maybe<({
        __typename?: 'SendPasswordResetEmailMutationPayload';
    } & Pick<SendPasswordResetEmailMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type ResetPasswordMutationVariables = Exact<{
    token?: Maybe<Scalars['String']>;
    newPassword: Scalars['String'];
}>;
export declare type ResetPasswordMutation = ({
    __typename?: 'Mutation';
} & {
    resetPassword?: Maybe<({
        __typename?: 'ResetPasswordMutationPayload';
    } & Pick<ResetPasswordMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type UpdateProfileMutationVariables = Exact<{
    username: Scalars['String'];
    title?: Maybe<Scalars['String']>;
    bio?: Maybe<Scalars['String']>;
    avatar?: Maybe<Scalars['String']>;
}>;
export declare type UpdateProfileMutation = ({
    __typename?: 'Mutation';
} & {
    updateProfile?: Maybe<({
        __typename?: 'UpdateProfileMutationPayload';
    } & Pick<UpdateProfileMutationPayload, 'successMessage'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & UserFieldsFragment)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type UpdateAccountSettingsMutationVariables = Exact<{
    email: Scalars['String'];
    backupEmail: Scalars['String'];
    commentReplyEmailPermission?: Maybe<Scalars['Boolean']>;
    threadCommentEmailPermission?: Maybe<Scalars['Boolean']>;
    newBadgeEmailPermission?: Maybe<Scalars['Boolean']>;
    commentReplyPushPermission?: Maybe<Scalars['Boolean']>;
    threadCommentPushPermission?: Maybe<Scalars['Boolean']>;
    newBadgePushPermission?: Maybe<Scalars['Boolean']>;
}>;
export declare type UpdateAccountSettingsMutation = ({
    __typename?: 'Mutation';
} & {
    updateAccountSettings?: Maybe<({
        __typename?: 'UpdateAccountSettingsMutationPayload';
    } & Pick<UpdateAccountSettingsMutationPayload, 'successMessage'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & UserFieldsFragment)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type ChangePasswordMutationVariables = Exact<{
    oldPassword: Scalars['String'];
    newPassword: Scalars['String'];
}>;
export declare type ChangePasswordMutation = ({
    __typename?: 'Mutation';
} & {
    changePassword?: Maybe<({
        __typename?: 'ChangePasswordMutationPayload';
    } & Pick<ChangePasswordMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type DeleteUserMutationVariables = Exact<{
    password: Scalars['String'];
}>;
export declare type DeleteUserMutation = ({
    __typename?: 'Mutation';
} & {
    deleteUser?: Maybe<({
        __typename?: 'DeleteUserMutationPayload';
    } & Pick<DeleteUserMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type VoteMutationVariables = Exact<{
    status: Scalars['Int'];
    comment?: Maybe<Scalars['ID']>;
    thread?: Maybe<Scalars['ID']>;
}>;
export declare type VoteMutation = ({
    __typename?: 'Mutation';
} & {
    vote?: Maybe<({
        __typename?: 'VoteMutationPayload';
    } & Pick<VoteMutationPayload, 'targetScore'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        vote?: Maybe<({
            __typename?: 'VoteObjectType';
        } & Pick<VoteObjectType, 'id' | 'status'>)>;
    })>;
});
export declare type UpdateSelectedBadgeMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type UpdateSelectedBadgeMutation = ({
    __typename?: 'Mutation';
} & {
    updateSelectedBadge?: Maybe<({
        __typename?: 'UpdateSelectedBadgeMutationPayload';
    } & Pick<UpdateSelectedBadgeMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        badgeProgress?: Maybe<({
            __typename?: 'BadgeProgressObjectType';
        } & BadgeProgressFieldsFragment)>;
    })>;
});
export declare type BadgesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type BadgesQuery = ({
    __typename?: 'Query';
} & {
    badges?: Maybe<Array<Maybe<({
        __typename?: 'BadgeObjectType';
    } & BadgeFieldsFragment)>>>;
});
export declare type RegisterFcmTokenMutationVariables = Exact<{
    token?: Maybe<Scalars['String']>;
}>;
export declare type RegisterFcmTokenMutation = ({
    __typename?: 'Mutation';
} & {
    registerFcmToken?: Maybe<({
        __typename?: 'RegisterFCMTokenMutationPayload';
    } & Pick<RegisterFcmTokenMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type UseInviteCodeAndLoginMutationVariables = Exact<{
    code: Scalars['String'];
    usernameOrEmail: Scalars['String'];
    password: Scalars['String'];
}>;
export declare type UseInviteCodeAndLoginMutation = ({
    __typename?: 'Mutation';
} & {
    useInviteCode?: Maybe<({
        __typename?: 'UseInviteCodeMutationPayload';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
    login?: Maybe<({
        __typename?: 'LoginMutationPayload';
    } & Pick<LoginMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & UserFieldsFragment)>;
    })>;
});
export declare const ActivityFieldsFragmentDoc: Apollo.DocumentNode;
export declare const PaginatedActivityFieldsFragmentDoc: Apollo.DocumentNode;
export declare const ThreadFieldsFragmentDoc: Apollo.DocumentNode;
export declare const PaginatedThreadFieldsFragmentDoc: Apollo.DocumentNode;
export declare const BadgeFieldsFragmentDoc: Apollo.DocumentNode;
export declare const BadgeProgressFieldsFragmentDoc: Apollo.DocumentNode;
export declare const UserFieldsFragmentDoc: Apollo.DocumentNode;
export declare const _CommentFieldsFragmentDoc: Apollo.DocumentNode;
export declare const CommentFieldsFragmentDoc: Apollo.DocumentNode;
export declare const ActivitiesDocument: Apollo.DocumentNode;
/**
 * __useActivitiesQuery__
 *
 * To run a query within a React component, call `useActivitiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivitiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivitiesQuery({
 *   variables: {
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useActivitiesQuery(baseOptions?: Apollo.QueryHookOptions<ActivitiesQuery, ActivitiesQueryVariables>): Apollo.QueryResult<ActivitiesQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useActivitiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivitiesQuery, ActivitiesQueryVariables>): Apollo.QueryTuple<ActivitiesQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type ActivitiesQueryHookResult = ReturnType<typeof useActivitiesQuery>;
export declare type ActivitiesLazyQueryHookResult = ReturnType<typeof useActivitiesLazyQuery>;
export declare type ActivitiesQueryResult = Apollo.QueryResult<ActivitiesQuery, ActivitiesQueryVariables>;
export declare const ActivityPreviewDocument: Apollo.DocumentNode;
/**
 * __useActivityPreviewQuery__
 *
 * To run a query within a React component, call `useActivityPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivityPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivityPreviewQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useActivityPreviewQuery(baseOptions?: Apollo.QueryHookOptions<ActivityPreviewQuery, ActivityPreviewQueryVariables>): Apollo.QueryResult<ActivityPreviewQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useActivityPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivityPreviewQuery, ActivityPreviewQueryVariables>): Apollo.QueryTuple<ActivityPreviewQuery, Exact<{
    [key: string]: never;
}>>;
export declare type ActivityPreviewQueryHookResult = ReturnType<typeof useActivityPreviewQuery>;
export declare type ActivityPreviewLazyQueryHookResult = ReturnType<typeof useActivityPreviewLazyQuery>;
export declare type ActivityPreviewQueryResult = Apollo.QueryResult<ActivityPreviewQuery, ActivityPreviewQueryVariables>;
export declare const MarkActivityAsReadDocument: Apollo.DocumentNode;
export declare type MarkActivityAsReadMutationFn = Apollo.MutationFunction<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>;
/**
 * __useMarkActivityAsReadMutation__
 *
 * To run a mutation, you first call `useMarkActivityAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMarkActivityAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [markActivityAsReadMutation, { data, loading, error }] = useMarkActivityAsReadMutation({
 *   variables: {
 *      id: // value for 'id'
 *      read: // value for 'read'
 *   },
 * });
 */
export declare function useMarkActivityAsReadMutation(baseOptions?: Apollo.MutationHookOptions<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>): Apollo.MutationTuple<MarkActivityAsReadMutation, Exact<{
    id?: string | null | undefined;
    read?: boolean | null | undefined;
}>>;
export declare type MarkActivityAsReadMutationHookResult = ReturnType<typeof useMarkActivityAsReadMutation>;
export declare type MarkActivityAsReadMutationResult = Apollo.MutationResult<MarkActivityAsReadMutation>;
export declare type MarkActivityAsReadMutationOptions = Apollo.BaseMutationOptions<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>;
export declare const GraphQlMarkAllActivitiesAsReadDocument: Apollo.DocumentNode;
export declare type GraphQlMarkAllActivitiesAsReadMutationFn = Apollo.MutationFunction<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>;
/**
 * __useGraphQlMarkAllActivitiesAsReadMutation__
 *
 * To run a mutation, you first call `useGraphQlMarkAllActivitiesAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlMarkAllActivitiesAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlMarkAllActivitiesAsReadMutation, { data, loading, error }] = useGraphQlMarkAllActivitiesAsReadMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlMarkAllActivitiesAsReadMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>): Apollo.MutationTuple<GraphQlMarkAllActivitiesAsReadMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlMarkAllActivitiesAsReadMutationHookResult = ReturnType<typeof useGraphQlMarkAllActivitiesAsReadMutation>;
export declare type GraphQlMarkAllActivitiesAsReadMutationResult = Apollo.MutationResult<GraphQlMarkAllActivitiesAsReadMutation>;
export declare type GraphQlMarkAllActivitiesAsReadMutationOptions = Apollo.BaseMutationOptions<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>;
export declare const CreateCommentDocument: Apollo.DocumentNode;
export declare type CreateCommentMutationFn = Apollo.MutationFunction<CreateCommentMutation, CreateCommentMutationVariables>;
/**
 * __useCreateCommentMutation__
 *
 * To run a mutation, you first call `useCreateCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentMutation, { data, loading, error }] = useCreateCommentMutation({
 *   variables: {
 *      user: // value for 'user'
 *      text: // value for 'text'
 *      image: // value for 'image'
 *      file: // value for 'file'
 *      thread: // value for 'thread'
 *      comment: // value for 'comment'
 *   },
 * });
 */
export declare function useCreateCommentMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentMutation, CreateCommentMutationVariables>): Apollo.MutationTuple<CreateCommentMutation, Exact<{
    user?: string | null | undefined;
    text: string;
    image?: string | null | undefined;
    file?: string | null | undefined;
    thread?: string | null | undefined;
    comment?: string | null | undefined;
}>>;
export declare type CreateCommentMutationHookResult = ReturnType<typeof useCreateCommentMutation>;
export declare type CreateCommentMutationResult = Apollo.MutationResult<CreateCommentMutation>;
export declare type CreateCommentMutationOptions = Apollo.BaseMutationOptions<CreateCommentMutation, CreateCommentMutationVariables>;
export declare const DeleteCommentDocument: Apollo.DocumentNode;
export declare type DeleteCommentMutationFn = Apollo.MutationFunction<DeleteCommentMutation, DeleteCommentMutationVariables>;
/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useDeleteCommentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCommentMutation, DeleteCommentMutationVariables>): Apollo.MutationTuple<DeleteCommentMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type DeleteCommentMutationHookResult = ReturnType<typeof useDeleteCommentMutation>;
export declare type DeleteCommentMutationResult = Apollo.MutationResult<DeleteCommentMutation>;
export declare type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<DeleteCommentMutation, DeleteCommentMutationVariables>;
export declare const CreateContactMessageDocument: Apollo.DocumentNode;
export declare type CreateContactMessageMutationFn = Apollo.MutationFunction<CreateContactMessageMutation, CreateContactMessageMutationVariables>;
/**
 * __useCreateContactMessageMutation__
 *
 * To run a mutation, you first call `useCreateContactMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateContactMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createContactMessageMutation, { data, loading, error }] = useCreateContactMessageMutation({
 *   variables: {
 *      subject: // value for 'subject'
 *      name: // value for 'name'
 *      email: // value for 'email'
 *      message: // value for 'message'
 *   },
 * });
 */
export declare function useCreateContactMessageMutation(baseOptions?: Apollo.MutationHookOptions<CreateContactMessageMutation, CreateContactMessageMutationVariables>): Apollo.MutationTuple<CreateContactMessageMutation, Exact<{
    subject?: string | null | undefined;
    name?: string | null | undefined;
    email?: string | null | undefined;
    message: string;
}>>;
export declare type CreateContactMessageMutationHookResult = ReturnType<typeof useCreateContactMessageMutation>;
export declare type CreateContactMessageMutationResult = Apollo.MutationResult<CreateContactMessageMutation>;
export declare type CreateContactMessageMutationOptions = Apollo.BaseMutationOptions<CreateContactMessageMutation, CreateContactMessageMutationVariables>;
export declare const ThreadsDocument: Apollo.DocumentNode;
/**
 * __useThreadsQuery__
 *
 * To run a query within a React component, call `useThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadsQuery({
 *   variables: {
 *      searchTerm: // value for 'searchTerm'
 *      ordering: // value for 'ordering'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useThreadsQuery(baseOptions?: Apollo.QueryHookOptions<ThreadsQuery, ThreadsQueryVariables>): Apollo.QueryResult<ThreadsQuery, Exact<{
    searchTerm?: string | null | undefined;
    ordering?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadsQuery, ThreadsQueryVariables>): Apollo.QueryTuple<ThreadsQuery, Exact<{
    searchTerm?: string | null | undefined;
    ordering?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type ThreadsQueryHookResult = ReturnType<typeof useThreadsQuery>;
export declare type ThreadsLazyQueryHookResult = ReturnType<typeof useThreadsLazyQuery>;
export declare type ThreadsQueryResult = Apollo.QueryResult<ThreadsQuery, ThreadsQueryVariables>;
export declare const ThreadDocument: Apollo.DocumentNode;
/**
 * __useThreadQuery__
 *
 * To run a query within a React component, call `useThreadQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export declare function useThreadQuery(baseOptions?: Apollo.QueryHookOptions<ThreadQuery, ThreadQueryVariables>): Apollo.QueryResult<ThreadQuery, Exact<{
    slug?: string | null | undefined;
}>>;
export declare function useThreadLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadQuery, ThreadQueryVariables>): Apollo.QueryTuple<ThreadQuery, Exact<{
    slug?: string | null | undefined;
}>>;
export declare type ThreadQueryHookResult = ReturnType<typeof useThreadQuery>;
export declare type ThreadLazyQueryHookResult = ReturnType<typeof useThreadLazyQuery>;
export declare type ThreadQueryResult = Apollo.QueryResult<ThreadQuery, ThreadQueryVariables>;
export declare const ThreadCommentsDocument: Apollo.DocumentNode;
/**
 * __useThreadCommentsQuery__
 *
 * To run a query within a React component, call `useThreadCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useThreadCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useThreadCommentsQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      ordering: // value for 'ordering'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useThreadCommentsQuery(baseOptions?: Apollo.QueryHookOptions<ThreadCommentsQuery, ThreadCommentsQueryVariables>): Apollo.QueryResult<ThreadCommentsQuery, Exact<{
    slug?: string | null | undefined;
    ordering?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useThreadCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ThreadCommentsQuery, ThreadCommentsQueryVariables>): Apollo.QueryTuple<ThreadCommentsQuery, Exact<{
    slug?: string | null | undefined;
    ordering?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type ThreadCommentsQueryHookResult = ReturnType<typeof useThreadCommentsQuery>;
export declare type ThreadCommentsLazyQueryHookResult = ReturnType<typeof useThreadCommentsLazyQuery>;
export declare type ThreadCommentsQueryResult = Apollo.QueryResult<ThreadCommentsQuery, ThreadCommentsQueryVariables>;
export declare const CreateThreadDocument: Apollo.DocumentNode;
export declare type CreateThreadMutationFn = Apollo.MutationFunction<CreateThreadMutation, CreateThreadMutationVariables>;
/**
 * __useCreateThreadMutation__
 *
 * To run a mutation, you first call `useCreateThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createThreadMutation, { data, loading, error }] = useCreateThreadMutation({
 *   variables: {
 *      title: // value for 'title'
 *      text: // value for 'text'
 *      image: // value for 'image'
 *   },
 * });
 */
export declare function useCreateThreadMutation(baseOptions?: Apollo.MutationHookOptions<CreateThreadMutation, CreateThreadMutationVariables>): Apollo.MutationTuple<CreateThreadMutation, Exact<{
    title: string;
    text?: string | null | undefined;
    image?: string | null | undefined;
}>>;
export declare type CreateThreadMutationHookResult = ReturnType<typeof useCreateThreadMutation>;
export declare type CreateThreadMutationResult = Apollo.MutationResult<CreateThreadMutation>;
export declare type CreateThreadMutationOptions = Apollo.BaseMutationOptions<CreateThreadMutation, CreateThreadMutationVariables>;
export declare const DeleteThreadDocument: Apollo.DocumentNode;
export declare type DeleteThreadMutationFn = Apollo.MutationFunction<DeleteThreadMutation, DeleteThreadMutationVariables>;
/**
 * __useDeleteThreadMutation__
 *
 * To run a mutation, you first call `useDeleteThreadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteThreadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteThreadMutation, { data, loading, error }] = useDeleteThreadMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useDeleteThreadMutation(baseOptions?: Apollo.MutationHookOptions<DeleteThreadMutation, DeleteThreadMutationVariables>): Apollo.MutationTuple<DeleteThreadMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type DeleteThreadMutationHookResult = ReturnType<typeof useDeleteThreadMutation>;
export declare type DeleteThreadMutationResult = Apollo.MutationResult<DeleteThreadMutation>;
export declare type DeleteThreadMutationOptions = Apollo.BaseMutationOptions<DeleteThreadMutation, DeleteThreadMutationVariables>;
export declare const StarredDocument: Apollo.DocumentNode;
/**
 * __useStarredQuery__
 *
 * To run a query within a React component, call `useStarredQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarredQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarredQuery({
 *   variables: {
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useStarredQuery(baseOptions?: Apollo.QueryHookOptions<StarredQuery, StarredQueryVariables>): Apollo.QueryResult<StarredQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useStarredLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarredQuery, StarredQueryVariables>): Apollo.QueryTuple<StarredQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type StarredQueryHookResult = ReturnType<typeof useStarredQuery>;
export declare type StarredLazyQueryHookResult = ReturnType<typeof useStarredLazyQuery>;
export declare type StarredQueryResult = Apollo.QueryResult<StarredQuery, StarredQueryVariables>;
export declare const StarDocument: Apollo.DocumentNode;
export declare type StarMutationFn = Apollo.MutationFunction<StarMutation, StarMutationVariables>;
/**
 * __useStarMutation__
 *
 * To run a mutation, you first call `useStarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [starMutation, { data, loading, error }] = useStarMutation({
 *   variables: {
 *      thread: // value for 'thread'
 *   },
 * });
 */
export declare function useStarMutation(baseOptions?: Apollo.MutationHookOptions<StarMutation, StarMutationVariables>): Apollo.MutationTuple<StarMutation, Exact<{
    thread: string;
}>>;
export declare type StarMutationHookResult = ReturnType<typeof useStarMutation>;
export declare type StarMutationResult = Apollo.MutationResult<StarMutation>;
export declare type StarMutationOptions = Apollo.BaseMutationOptions<StarMutation, StarMutationVariables>;
export declare const UserMeDocument: Apollo.DocumentNode;
/**
 * __useUserMeQuery__
 *
 * To run a query within a React component, call `useUserMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserMeQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useUserMeQuery(baseOptions?: Apollo.QueryHookOptions<UserMeQuery, UserMeQueryVariables>): Apollo.QueryResult<UserMeQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useUserMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserMeQuery, UserMeQueryVariables>): Apollo.QueryTuple<UserMeQuery, Exact<{
    [key: string]: never;
}>>;
export declare type UserMeQueryHookResult = ReturnType<typeof useUserMeQuery>;
export declare type UserMeLazyQueryHookResult = ReturnType<typeof useUserMeLazyQuery>;
export declare type UserMeQueryResult = Apollo.QueryResult<UserMeQuery, UserMeQueryVariables>;
export declare const UserDocument: Apollo.DocumentNode;
/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export declare function useUserQuery(baseOptions?: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>): Apollo.QueryResult<UserQuery, Exact<{
    slug?: string | null | undefined;
}>>;
export declare function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>): Apollo.QueryTuple<UserQuery, Exact<{
    slug?: string | null | undefined;
}>>;
export declare type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export declare type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export declare type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export declare const UserThreadsDocument: Apollo.DocumentNode;
/**
 * __useUserThreadsQuery__
 *
 * To run a query within a React component, call `useUserThreadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserThreadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserThreadsQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useUserThreadsQuery(baseOptions?: Apollo.QueryHookOptions<UserThreadsQuery, UserThreadsQueryVariables>): Apollo.QueryResult<UserThreadsQuery, Exact<{
    slug?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useUserThreadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserThreadsQuery, UserThreadsQueryVariables>): Apollo.QueryTuple<UserThreadsQuery, Exact<{
    slug?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type UserThreadsQueryHookResult = ReturnType<typeof useUserThreadsQuery>;
export declare type UserThreadsLazyQueryHookResult = ReturnType<typeof useUserThreadsLazyQuery>;
export declare type UserThreadsQueryResult = Apollo.QueryResult<UserThreadsQuery, UserThreadsQueryVariables>;
export declare const UserCommentsDocument: Apollo.DocumentNode;
/**
 * __useUserCommentsQuery__
 *
 * To run a query within a React component, call `useUserCommentsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserCommentsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserCommentsQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useUserCommentsQuery(baseOptions?: Apollo.QueryHookOptions<UserCommentsQuery, UserCommentsQueryVariables>): Apollo.QueryResult<UserCommentsQuery, Exact<{
    slug?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useUserCommentsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserCommentsQuery, UserCommentsQueryVariables>): Apollo.QueryTuple<UserCommentsQuery, Exact<{
    slug?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type UserCommentsQueryHookResult = ReturnType<typeof useUserCommentsQuery>;
export declare type UserCommentsLazyQueryHookResult = ReturnType<typeof useUserCommentsLazyQuery>;
export declare type UserCommentsQueryResult = Apollo.QueryResult<UserCommentsQuery, UserCommentsQueryVariables>;
export declare const RegisterDocument: Apollo.DocumentNode;
export declare type RegisterMutationFn = Apollo.MutationFunction<RegisterMutation, RegisterMutationVariables>;
/**
 * __useRegisterMutation__
 *
 * To run a mutation, you first call `useRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerMutation, { data, loading, error }] = useRegisterMutation({
 *   variables: {
 *      username: // value for 'username'
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useRegisterMutation(baseOptions?: Apollo.MutationHookOptions<RegisterMutation, RegisterMutationVariables>): Apollo.MutationTuple<RegisterMutation, Exact<{
    username: string;
    email: string;
    password: string;
}>>;
export declare type RegisterMutationHookResult = ReturnType<typeof useRegisterMutation>;
export declare type RegisterMutationResult = Apollo.MutationResult<RegisterMutation>;
export declare type RegisterMutationOptions = Apollo.BaseMutationOptions<RegisterMutation, RegisterMutationVariables>;
export declare const LoginDocument: Apollo.DocumentNode;
export declare type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;
/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      usernameOrEmail: // value for 'usernameOrEmail'
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>): Apollo.MutationTuple<LoginMutation, Exact<{
    usernameOrEmail: string;
    password: string;
}>>;
export declare type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export declare type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export declare type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export declare const GraphQlLogoutDocument: Apollo.DocumentNode;
export declare type GraphQlLogoutMutationFn = Apollo.MutationFunction<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>;
/**
 * __useGraphQlLogoutMutation__
 *
 * To run a mutation, you first call `useGraphQlLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlLogoutMutation, { data, loading, error }] = useGraphQlLogoutMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlLogoutMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>): Apollo.MutationTuple<GraphQlLogoutMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlLogoutMutationHookResult = ReturnType<typeof useGraphQlLogoutMutation>;
export declare type GraphQlLogoutMutationResult = Apollo.MutationResult<GraphQlLogoutMutation>;
export declare type GraphQlLogoutMutationOptions = Apollo.BaseMutationOptions<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>;
export declare const GraphQlResendVerificationEmailDocument: Apollo.DocumentNode;
export declare type GraphQlResendVerificationEmailMutationFn = Apollo.MutationFunction<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>;
/**
 * __useGraphQlResendVerificationEmailMutation__
 *
 * To run a mutation, you first call `useGraphQlResendVerificationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlResendVerificationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlResendVerificationEmailMutation, { data, loading, error }] = useGraphQlResendVerificationEmailMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlResendVerificationEmailMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>): Apollo.MutationTuple<GraphQlResendVerificationEmailMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlResendVerificationEmailMutationHookResult = ReturnType<typeof useGraphQlResendVerificationEmailMutation>;
export declare type GraphQlResendVerificationEmailMutationResult = Apollo.MutationResult<GraphQlResendVerificationEmailMutation>;
export declare type GraphQlResendVerificationEmailMutationOptions = Apollo.BaseMutationOptions<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>;
export declare const GraphQlMyDataDocument: Apollo.DocumentNode;
export declare type GraphQlMyDataMutationFn = Apollo.MutationFunction<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>;
/**
 * __useGraphQlMyDataMutation__
 *
 * To run a mutation, you first call `useGraphQlMyDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlMyDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlMyDataMutation, { data, loading, error }] = useGraphQlMyDataMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlMyDataMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>): Apollo.MutationTuple<GraphQlMyDataMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlMyDataMutationHookResult = ReturnType<typeof useGraphQlMyDataMutation>;
export declare type GraphQlMyDataMutationResult = Apollo.MutationResult<GraphQlMyDataMutation>;
export declare type GraphQlMyDataMutationOptions = Apollo.BaseMutationOptions<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>;
export declare const VerifyAccountDocument: Apollo.DocumentNode;
export declare type VerifyAccountMutationFn = Apollo.MutationFunction<VerifyAccountMutation, VerifyAccountMutationVariables>;
/**
 * __useVerifyAccountMutation__
 *
 * To run a mutation, you first call `useVerifyAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyAccountMutation, { data, loading, error }] = useVerifyAccountMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export declare function useVerifyAccountMutation(baseOptions?: Apollo.MutationHookOptions<VerifyAccountMutation, VerifyAccountMutationVariables>): Apollo.MutationTuple<VerifyAccountMutation, Exact<{
    token?: string | null | undefined;
}>>;
export declare type VerifyAccountMutationHookResult = ReturnType<typeof useVerifyAccountMutation>;
export declare type VerifyAccountMutationResult = Apollo.MutationResult<VerifyAccountMutation>;
export declare type VerifyAccountMutationOptions = Apollo.BaseMutationOptions<VerifyAccountMutation, VerifyAccountMutationVariables>;
export declare const SendPasswordResetEmailDocument: Apollo.DocumentNode;
export declare type SendPasswordResetEmailMutationFn = Apollo.MutationFunction<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>;
/**
 * __useSendPasswordResetEmailMutation__
 *
 * To run a mutation, you first call `useSendPasswordResetEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendPasswordResetEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendPasswordResetEmailMutation, { data, loading, error }] = useSendPasswordResetEmailMutation({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export declare function useSendPasswordResetEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>): Apollo.MutationTuple<SendPasswordResetEmailMutation, Exact<{
    email: string;
}>>;
export declare type SendPasswordResetEmailMutationHookResult = ReturnType<typeof useSendPasswordResetEmailMutation>;
export declare type SendPasswordResetEmailMutationResult = Apollo.MutationResult<SendPasswordResetEmailMutation>;
export declare type SendPasswordResetEmailMutationOptions = Apollo.BaseMutationOptions<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>;
export declare const ResetPasswordDocument: Apollo.DocumentNode;
export declare type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;
/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      token: // value for 'token'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export declare function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>): Apollo.MutationTuple<ResetPasswordMutation, Exact<{
    token?: string | null | undefined;
    newPassword: string;
}>>;
export declare type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export declare type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export declare type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export declare const UpdateProfileDocument: Apollo.DocumentNode;
export declare type UpdateProfileMutationFn = Apollo.MutationFunction<UpdateProfileMutation, UpdateProfileMutationVariables>;
/**
 * __useUpdateProfileMutation__
 *
 * To run a mutation, you first call `useUpdateProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProfileMutation, { data, loading, error }] = useUpdateProfileMutation({
 *   variables: {
 *      username: // value for 'username'
 *      title: // value for 'title'
 *      bio: // value for 'bio'
 *      avatar: // value for 'avatar'
 *   },
 * });
 */
export declare function useUpdateProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProfileMutation, UpdateProfileMutationVariables>): Apollo.MutationTuple<UpdateProfileMutation, Exact<{
    username: string;
    title?: string | null | undefined;
    bio?: string | null | undefined;
    avatar?: string | null | undefined;
}>>;
export declare type UpdateProfileMutationHookResult = ReturnType<typeof useUpdateProfileMutation>;
export declare type UpdateProfileMutationResult = Apollo.MutationResult<UpdateProfileMutation>;
export declare type UpdateProfileMutationOptions = Apollo.BaseMutationOptions<UpdateProfileMutation, UpdateProfileMutationVariables>;
export declare const UpdateAccountSettingsDocument: Apollo.DocumentNode;
export declare type UpdateAccountSettingsMutationFn = Apollo.MutationFunction<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>;
/**
 * __useUpdateAccountSettingsMutation__
 *
 * To run a mutation, you first call `useUpdateAccountSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAccountSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAccountSettingsMutation, { data, loading, error }] = useUpdateAccountSettingsMutation({
 *   variables: {
 *      email: // value for 'email'
 *      backupEmail: // value for 'backupEmail'
 *      commentReplyEmailPermission: // value for 'commentReplyEmailPermission'
 *      threadCommentEmailPermission: // value for 'threadCommentEmailPermission'
 *      newBadgeEmailPermission: // value for 'newBadgeEmailPermission'
 *      commentReplyPushPermission: // value for 'commentReplyPushPermission'
 *      threadCommentPushPermission: // value for 'threadCommentPushPermission'
 *      newBadgePushPermission: // value for 'newBadgePushPermission'
 *   },
 * });
 */
export declare function useUpdateAccountSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>): Apollo.MutationTuple<UpdateAccountSettingsMutation, Exact<{
    email: string;
    backupEmail: string;
    commentReplyEmailPermission?: boolean | null | undefined;
    threadCommentEmailPermission?: boolean | null | undefined;
    newBadgeEmailPermission?: boolean | null | undefined;
    commentReplyPushPermission?: boolean | null | undefined;
    threadCommentPushPermission?: boolean | null | undefined;
    newBadgePushPermission?: boolean | null | undefined;
}>>;
export declare type UpdateAccountSettingsMutationHookResult = ReturnType<typeof useUpdateAccountSettingsMutation>;
export declare type UpdateAccountSettingsMutationResult = Apollo.MutationResult<UpdateAccountSettingsMutation>;
export declare type UpdateAccountSettingsMutationOptions = Apollo.BaseMutationOptions<UpdateAccountSettingsMutation, UpdateAccountSettingsMutationVariables>;
export declare const ChangePasswordDocument: Apollo.DocumentNode;
export declare type ChangePasswordMutationFn = Apollo.MutationFunction<ChangePasswordMutation, ChangePasswordMutationVariables>;
/**
 * __useChangePasswordMutation__
 *
 * To run a mutation, you first call `useChangePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changePasswordMutation, { data, loading, error }] = useChangePasswordMutation({
 *   variables: {
 *      oldPassword: // value for 'oldPassword'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export declare function useChangePasswordMutation(baseOptions?: Apollo.MutationHookOptions<ChangePasswordMutation, ChangePasswordMutationVariables>): Apollo.MutationTuple<ChangePasswordMutation, Exact<{
    oldPassword: string;
    newPassword: string;
}>>;
export declare type ChangePasswordMutationHookResult = ReturnType<typeof useChangePasswordMutation>;
export declare type ChangePasswordMutationResult = Apollo.MutationResult<ChangePasswordMutation>;
export declare type ChangePasswordMutationOptions = Apollo.BaseMutationOptions<ChangePasswordMutation, ChangePasswordMutationVariables>;
export declare const DeleteUserDocument: Apollo.DocumentNode;
export declare type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;
/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>): Apollo.MutationTuple<DeleteUserMutation, Exact<{
    password: string;
}>>;
export declare type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export declare type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export declare type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export declare const VoteDocument: Apollo.DocumentNode;
export declare type VoteMutationFn = Apollo.MutationFunction<VoteMutation, VoteMutationVariables>;
/**
 * __useVoteMutation__
 *
 * To run a mutation, you first call `useVoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voteMutation, { data, loading, error }] = useVoteMutation({
 *   variables: {
 *      status: // value for 'status'
 *      comment: // value for 'comment'
 *      thread: // value for 'thread'
 *   },
 * });
 */
export declare function useVoteMutation(baseOptions?: Apollo.MutationHookOptions<VoteMutation, VoteMutationVariables>): Apollo.MutationTuple<VoteMutation, Exact<{
    status: number;
    comment?: string | null | undefined;
    thread?: string | null | undefined;
}>>;
export declare type VoteMutationHookResult = ReturnType<typeof useVoteMutation>;
export declare type VoteMutationResult = Apollo.MutationResult<VoteMutation>;
export declare type VoteMutationOptions = Apollo.BaseMutationOptions<VoteMutation, VoteMutationVariables>;
export declare const UpdateSelectedBadgeDocument: Apollo.DocumentNode;
export declare type UpdateSelectedBadgeMutationFn = Apollo.MutationFunction<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>;
/**
 * __useUpdateSelectedBadgeMutation__
 *
 * To run a mutation, you first call `useUpdateSelectedBadgeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSelectedBadgeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSelectedBadgeMutation, { data, loading, error }] = useUpdateSelectedBadgeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useUpdateSelectedBadgeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>): Apollo.MutationTuple<UpdateSelectedBadgeMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type UpdateSelectedBadgeMutationHookResult = ReturnType<typeof useUpdateSelectedBadgeMutation>;
export declare type UpdateSelectedBadgeMutationResult = Apollo.MutationResult<UpdateSelectedBadgeMutation>;
export declare type UpdateSelectedBadgeMutationOptions = Apollo.BaseMutationOptions<UpdateSelectedBadgeMutation, UpdateSelectedBadgeMutationVariables>;
export declare const BadgesDocument: Apollo.DocumentNode;
/**
 * __useBadgesQuery__
 *
 * To run a query within a React component, call `useBadgesQuery` and pass it any options that fit your needs.
 * When your component renders, `useBadgesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBadgesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useBadgesQuery(baseOptions?: Apollo.QueryHookOptions<BadgesQuery, BadgesQueryVariables>): Apollo.QueryResult<BadgesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useBadgesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BadgesQuery, BadgesQueryVariables>): Apollo.QueryTuple<BadgesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type BadgesQueryHookResult = ReturnType<typeof useBadgesQuery>;
export declare type BadgesLazyQueryHookResult = ReturnType<typeof useBadgesLazyQuery>;
export declare type BadgesQueryResult = Apollo.QueryResult<BadgesQuery, BadgesQueryVariables>;
export declare const RegisterFcmTokenDocument: Apollo.DocumentNode;
export declare type RegisterFcmTokenMutationFn = Apollo.MutationFunction<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>;
/**
 * __useRegisterFcmTokenMutation__
 *
 * To run a mutation, you first call `useRegisterFcmTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterFcmTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerFcmTokenMutation, { data, loading, error }] = useRegisterFcmTokenMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export declare function useRegisterFcmTokenMutation(baseOptions?: Apollo.MutationHookOptions<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>): Apollo.MutationTuple<RegisterFcmTokenMutation, Exact<{
    token?: string | null | undefined;
}>>;
export declare type RegisterFcmTokenMutationHookResult = ReturnType<typeof useRegisterFcmTokenMutation>;
export declare type RegisterFcmTokenMutationResult = Apollo.MutationResult<RegisterFcmTokenMutation>;
export declare type RegisterFcmTokenMutationOptions = Apollo.BaseMutationOptions<RegisterFcmTokenMutation, RegisterFcmTokenMutationVariables>;
export declare const UseInviteCodeAndLoginDocument: Apollo.DocumentNode;
export declare type UseInviteCodeAndLoginMutationFn = Apollo.MutationFunction<UseInviteCodeAndLoginMutation, UseInviteCodeAndLoginMutationVariables>;
/**
 * __useUseInviteCodeAndLoginMutation__
 *
 * To run a mutation, you first call `useUseInviteCodeAndLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUseInviteCodeAndLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [useInviteCodeAndLoginMutation, { data, loading, error }] = useUseInviteCodeAndLoginMutation({
 *   variables: {
 *      code: // value for 'code'
 *      usernameOrEmail: // value for 'usernameOrEmail'
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useUseInviteCodeAndLoginMutation(baseOptions?: Apollo.MutationHookOptions<UseInviteCodeAndLoginMutation, UseInviteCodeAndLoginMutationVariables>): Apollo.MutationTuple<UseInviteCodeAndLoginMutation, Exact<{
    code: string;
    usernameOrEmail: string;
    password: string;
}>>;
export declare type UseInviteCodeAndLoginMutationHookResult = ReturnType<typeof useUseInviteCodeAndLoginMutation>;
export declare type UseInviteCodeAndLoginMutationResult = Apollo.MutationResult<UseInviteCodeAndLoginMutation>;
export declare type UseInviteCodeAndLoginMutationOptions = Apollo.BaseMutationOptions<UseInviteCodeAndLoginMutation, UseInviteCodeAndLoginMutationVariables>;
