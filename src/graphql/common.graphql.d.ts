/* af7869e17831ca20035c98ceac9070094350d7ba
 * This file is automatically generated by graphql-let. */

import * as Apollo from '@apollo/client';
export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export declare type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export declare type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    /**
     * The `DateTime` scalar type represents a DateTime
     * value as specified by
     * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
     */
    DateTime: any;
    /**
     * The `Date` scalar type represents a Date
     * value as specified by
     * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
     */
    Date: any;
};
export declare type Query = {
    __typename?: 'Query';
    /**
     * Return comments filtered by query params.
     *
     * Results are paginated.
     */
    comments?: Maybe<PaginatedCommentObjectType>;
    /** Return comments filtered by query params. */
    discussion?: Maybe<Array<Maybe<CommentObjectType>>>;
    /**
     * Return a selection of courses, resources and schools that are most relevant
     * to discuss for the given user.
     *
     * Only allowed for authenticated users.
     */
    discussionSuggestions?: Maybe<Array<Maybe<DiscussionsUnion>>>;
    /**
     * Return suggested courses, resources and comments based on secret Skole AI-
     * powered algorithms.
     */
    suggestions?: Maybe<Array<Maybe<SuggestionsUnion>>>;
    /** Return preview of the suggestions. */
    suggestionsPreview?: Maybe<Array<Maybe<SuggestionsUnion>>>;
    /**
     * Return user profile of the user making the query.
     *
     * Only allowed for authenticated users.
     */
    userMe?: Maybe<UserObjectType>;
    /**
     * Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead.
     *
     * Superusers cannot be queried.
     */
    user?: Maybe<UserObjectType>;
    /**
     * Filter results based on the school ID.
     *
     * Results are sorted alphabetically.
     *
     * Results are paginated.
     */
    subjects?: Maybe<PaginatedSubjectObjectType>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted alphabetically.
     */
    autocompleteSubjects?: Maybe<Array<Maybe<SubjectObjectType>>>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    subject?: Maybe<SubjectObjectType>;
    /** Return the dynamic page IDs that frontend needs to build a `sitemap.xml`. */
    sitemap?: Maybe<SitemapObjectType>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted by creation time.
     */
    autocompleteSchoolTypes?: Maybe<Array<Maybe<SchoolTypeObjectType>>>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    schoolType?: Maybe<SchoolTypeObjectType>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted alphabetically.
     */
    autocompleteSchools?: Maybe<Array<Maybe<SchoolObjectType>>>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    school?: Maybe<SchoolObjectType>;
    resourceTypes?: Maybe<Array<Maybe<ResourceTypeObjectType>>>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted by creation time.
     */
    autocompleteResourceTypes?: Maybe<Array<Maybe<ResourceTypeObjectType>>>;
    /**
     * Return resources filtered by query params.
     *
     * Results are sorted by creation time.
     *
     * Results are paginated.
     */
    resources?: Maybe<PaginatedResourceObjectType>;
    /**
     * Return starred resources of the user making the query.
     *
     * Results are sorted by creation time.
     *
     * Only allowed for authenticated users.
     *
     * Results are paginated.
     */
    starredResources?: Maybe<PaginatedResourceObjectType>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    resource?: Maybe<ResourceObjectType>;
    /**
     * Return courses filtered by query params.
     *
     * The `search_term` can be either the course name or the course code.
     *
     * Results are sorted either manually based on query params or by secret Skole AI-
     * powered algorithms.
     *
     * Results are paginated.
     */
    courses?: Maybe<PaginatedCourseObjectType>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted by secret Skole AI-powered algorithms.
     */
    autocompleteCourses?: Maybe<Array<Maybe<CourseObjectType>>>;
    /**
     * Return starred courses of the user making the query.
     *
     * Results are sorted by creation time. Return an empty list for unauthenticated
     * users.
     *
     * Only allowed for authenticated users.
     *
     * Results are paginated.
     */
    starredCourses?: Maybe<PaginatedCourseObjectType>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    course?: Maybe<CourseObjectType>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted alphabetically.
     */
    autocompleteCountries?: Maybe<Array<Maybe<CountryObjectType>>>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    country?: Maybe<CountryObjectType>;
    /**
     * Return limited amount of results for autocomplete fields.
     *
     * Results are sorted alphabetically.
     */
    autocompleteCities?: Maybe<Array<Maybe<CityObjectType>>>;
    /** Return a single object based on the ID. If an object is not found or it has been soft deleted, return `null` instead. */
    city?: Maybe<CityObjectType>;
    /**
     * Return all activity of to the user making the query.
     *
     * Results are sorted by creation time.
     *
     * Only allowed for authenticated users.
     *
     * Results are paginated.
     */
    activities?: Maybe<PaginatedActivityObjectType>;
    /**
     * Return limited amount of activity of user making the query for a preview.
     *
     * Only allowed for authenticated users.
     */
    activityPreview?: Maybe<Array<Maybe<ActivityObjectType>>>;
};
export declare type QueryCommentsArgs = {
    user?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryDiscussionArgs = {
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
    school?: Maybe<Scalars['ID']>;
};
export declare type QueryUserArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QuerySubjectsArgs = {
    school?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryAutocompleteSubjectsArgs = {
    name?: Maybe<Scalars['String']>;
};
export declare type QuerySubjectArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QuerySchoolTypeArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QueryAutocompleteSchoolsArgs = {
    name?: Maybe<Scalars['String']>;
};
export declare type QuerySchoolArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QueryResourcesArgs = {
    user?: Maybe<Scalars['ID']>;
    course?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
    ordering?: Maybe<Scalars['String']>;
};
export declare type QueryStarredResourcesArgs = {
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryResourceArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QueryCoursesArgs = {
    searchTerm?: Maybe<Scalars['String']>;
    subject?: Maybe<Scalars['ID']>;
    school?: Maybe<Scalars['ID']>;
    schoolType?: Maybe<Scalars['ID']>;
    country?: Maybe<Scalars['ID']>;
    city?: Maybe<Scalars['ID']>;
    user?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
    ordering?: Maybe<Scalars['String']>;
};
export declare type QueryAutocompleteCoursesArgs = {
    school?: Maybe<Scalars['ID']>;
    name?: Maybe<Scalars['String']>;
};
export declare type QueryStarredCoursesArgs = {
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
export declare type QueryCourseArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QueryCountryArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QueryCityArgs = {
    id?: Maybe<Scalars['ID']>;
};
export declare type QueryActivitiesArgs = {
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
};
/**
 * Models one comment posted on a comment thread.
 *
 * Results are paginated.
 */
export declare type PaginatedCommentObjectType = {
    __typename?: 'PaginatedCommentObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<CommentObjectType>>>;
};
export declare type CommentObjectType = {
    __typename?: 'CommentObjectType';
    id: Scalars['ID'];
    user?: Maybe<UserObjectType>;
    text: Scalars['String'];
    attachment: Scalars['String'];
    course?: Maybe<CourseObjectType>;
    resource?: Maybe<ResourceObjectType>;
    comment?: Maybe<CommentObjectType>;
    school?: Maybe<SchoolObjectType>;
    modified: Scalars['DateTime'];
    created: Scalars['DateTime'];
    replyComments: Array<CommentObjectType>;
    score?: Maybe<Scalars['Int']>;
    vote?: Maybe<VoteObjectType>;
    replyCount?: Maybe<Scalars['Int']>;
    attachmentThumbnail?: Maybe<Scalars['String']>;
};
/**
 * Models one user on the platform.
 *
 * The following fields are private, meaning they are returned only if the user is
 * querying one's own profile: `email`, `verified`, `school`, `subject`.
 *
 * For instances that are not the user's own user profile, these fields will return a
 * `null` value.
 */
export declare type UserObjectType = {
    __typename?: 'UserObjectType';
    id: Scalars['ID'];
    username: Scalars['String'];
    email?: Maybe<Scalars['String']>;
    title: Scalars['String'];
    bio: Scalars['String'];
    avatar?: Maybe<Scalars['String']>;
    score?: Maybe<Scalars['Int']>;
    created: Scalars['DateTime'];
    verified?: Maybe<Scalars['Boolean']>;
    avatarThumbnail?: Maybe<Scalars['String']>;
    school?: Maybe<SchoolObjectType>;
    subject?: Maybe<SubjectObjectType>;
    rank?: Maybe<Scalars['String']>;
    badges?: Maybe<Array<Maybe<BadgeObjectType>>>;
    unreadActivityCount?: Maybe<Scalars['Int']>;
};
/** Models one school on the platform. */
export declare type SchoolObjectType = {
    __typename?: 'SchoolObjectType';
    id: Scalars['ID'];
    schoolType?: Maybe<SchoolTypeObjectType>;
    city?: Maybe<CityObjectType>;
    courses: Array<CourseObjectType>;
    name?: Maybe<Scalars['String']>;
    country?: Maybe<CountryObjectType>;
    subjects?: Maybe<Array<Maybe<SubjectObjectType>>>;
    commentCount?: Maybe<Scalars['Int']>;
};
/** Models one type of school, e.g. University of High School. */
export declare type SchoolTypeObjectType = {
    __typename?: 'SchoolTypeObjectType';
    id: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
};
/** Models one city, e.g. Turku or Helsinki. */
export declare type CityObjectType = {
    __typename?: 'CityObjectType';
    id: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
};
export declare type CourseObjectType = {
    __typename?: 'CourseObjectType';
    id: Scalars['ID'];
    name: Scalars['String'];
    code: Scalars['String'];
    subjects: Array<SubjectObjectType>;
    school: SchoolObjectType;
    user?: Maybe<UserObjectType>;
    modified: Scalars['DateTime'];
    created: Scalars['DateTime'];
    comments: Array<CommentObjectType>;
    resources: Array<ResourceObjectType>;
    starred?: Maybe<Scalars['Boolean']>;
    score?: Maybe<Scalars['Int']>;
    vote?: Maybe<VoteObjectType>;
    starCount?: Maybe<Scalars['Int']>;
    resourceCount?: Maybe<Scalars['Int']>;
    commentCount?: Maybe<Scalars['Int']>;
};
/** Models one studyable subject, e.g. Computer Engineering. */
export declare type SubjectObjectType = {
    __typename?: 'SubjectObjectType';
    id: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
    courseCount?: Maybe<Scalars['Int']>;
    resourceCount?: Maybe<Scalars['Int']>;
};
export declare type ResourceObjectType = {
    __typename?: 'ResourceObjectType';
    id: Scalars['ID'];
    resourceType?: Maybe<ResourceTypeObjectType>;
    title: Scalars['String'];
    file: Scalars['String'];
    date: Scalars['Date'];
    course: CourseObjectType;
    downloads: Scalars['Int'];
    user?: Maybe<UserObjectType>;
    author?: Maybe<AuthorObjectType>;
    modified: Scalars['DateTime'];
    created: Scalars['DateTime'];
    comments: Array<CommentObjectType>;
    starred?: Maybe<Scalars['Boolean']>;
    score?: Maybe<Scalars['Int']>;
    vote?: Maybe<VoteObjectType>;
    school?: Maybe<SchoolObjectType>;
    starCount?: Maybe<Scalars['Int']>;
    commentCount?: Maybe<Scalars['Int']>;
};
/** Models one type of resource, e.g. an exam or a note. */
export declare type ResourceTypeObjectType = {
    __typename?: 'ResourceTypeObjectType';
    id: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
};
/** Models the author (=copyright owner) of a resource. */
export declare type AuthorObjectType = {
    __typename?: 'AuthorObjectType';
    id: Scalars['ID'];
    name: Scalars['String'];
    user?: Maybe<UserObjectType>;
};
/** Models one vote on either comment, course or resource. */
export declare type VoteObjectType = {
    __typename?: 'VoteObjectType';
    id: Scalars['ID'];
    user?: Maybe<UserObjectType>;
    status?: Maybe<Scalars['Int']>;
    comment?: Maybe<CommentObjectType>;
    course?: Maybe<CourseObjectType>;
    resource?: Maybe<ResourceObjectType>;
};
/** Models one country, e.g. Finland or Sweden. */
export declare type CountryObjectType = {
    __typename?: 'CountryObjectType';
    id: Scalars['ID'];
    name?: Maybe<Scalars['String']>;
};
/** Models a badge awarded for a user, e.g `Moderator`. */
export declare type BadgeObjectType = {
    __typename?: 'BadgeObjectType';
    id: Scalars['ID'];
    name: Scalars['String'];
    description: Scalars['String'];
};
export declare type DiscussionsUnion = CourseObjectType | ResourceObjectType | SchoolObjectType;
export declare type SuggestionsUnion = CourseObjectType | ResourceObjectType | CommentObjectType;
/**
 * Models one studyable subject, e.g. Computer Engineering.
 *
 * Results are paginated.
 */
export declare type PaginatedSubjectObjectType = {
    __typename?: 'PaginatedSubjectObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<SubjectObjectType>>>;
};
export declare type SitemapObjectType = {
    __typename?: 'SitemapObjectType';
    courses: Array<SitemapEntryObjectType>;
    resources: Array<SitemapEntryObjectType>;
    schools: Array<SitemapEntryObjectType>;
    users: Array<SitemapEntryObjectType>;
};
export declare type SitemapEntryObjectType = {
    __typename?: 'SitemapEntryObjectType';
    id: Scalars['ID'];
    modified?: Maybe<Scalars['Date']>;
};
/**
 * Models one user-uploaded resource.
 *
 * Results are paginated.
 */
export declare type PaginatedResourceObjectType = {
    __typename?: 'PaginatedResourceObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<ResourceObjectType>>>;
};
/**
 * Models one course.
 *
 * Results are paginated.
 */
export declare type PaginatedCourseObjectType = {
    __typename?: 'PaginatedCourseObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<CourseObjectType>>>;
};
/**
 * Models a single activity of a users activity feed.
 *
 * Results are paginated.
 */
export declare type PaginatedActivityObjectType = {
    __typename?: 'PaginatedActivityObjectType';
    page?: Maybe<Scalars['Int']>;
    pages?: Maybe<Scalars['Int']>;
    hasNext?: Maybe<Scalars['Boolean']>;
    hasPrev?: Maybe<Scalars['Boolean']>;
    count?: Maybe<Scalars['Int']>;
    objects?: Maybe<Array<Maybe<ActivityObjectType>>>;
};
/** Models a single activity of a users activity feed. */
export declare type ActivityObjectType = {
    __typename?: 'ActivityObjectType';
    id: Scalars['ID'];
    targetUser?: Maybe<UserObjectType>;
    course?: Maybe<CourseObjectType>;
    resource?: Maybe<ResourceObjectType>;
    comment?: Maybe<CommentObjectType>;
    read?: Maybe<Scalars['Boolean']>;
    description?: Maybe<Scalars['String']>;
};
export declare type Mutation = {
    __typename?: 'Mutation';
    /**
     * Start a course or a resource remove the star if it already exists.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    star?: Maybe<StarMutationPayload>;
    /**
     * Upvote, downvote or remove a vote from a course, resource or a comment.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    vote?: Maybe<VoteMutationPayload>;
    /**
     * Register a new user.
     *
     * Check if there is an existing user with that email or username. Check that account
     * is not deactivated. By default, set the user's account as unverified. After
     * successful registration, send account verification email.
     */
    register?: Maybe<RegisterMutationPayload>;
    /**
     * Receive the token that was sent by email.
     *
     * If the token is valid, verify the user's account.
     */
    verifyAccount?: Maybe<VerifyAccountMutationPayload>;
    /**
     * Send the verification email again.
     *
     * Return an error in the following cases:
     * - A user account with the provided email address was not found.
     * - An unknown error while sending the email occurred.
     * - The user has already verified one's account.
     */
    resendVerificationEmail?: Maybe<ResendVerificationEmailMutation>;
    /**
     * Send password reset email.
     *
     * Return an error in the following cases:
     * - A user account with the provided email address was not found.
     * - An unknown error while sending the email occurred.
     */
    sendPasswordResetEmail?: Maybe<SendPasswordResetEmailMutationPayload>;
    /**
     * Change user's password without knowing the old password.
     *
     * Receive the token that was sent by email. Revoke refresh token and require the user
     * to log in again with one's new password.
     */
    resetPassword?: Maybe<ResetPasswordMutationPayload>;
    /**
     * Obtain JSON web token and user information.
     *
     * Non-verified users can still login.
     */
    login?: Maybe<LoginMutationPayload>;
    /**
     * Delete JSON web token cookie and logout.
     *
     * This sets the `Set-Cookie` header so that the JWT token cookie gets automatically
     * deleted in frontend.
     */
    logout?: Maybe<LogoutMutation>;
    /**
     * Change password with a requirement of knowing the old password.
     *
     * Only allowed for authenticated users.
     */
    changePassword?: Maybe<ChangePasswordMutationPayload>;
    /**
     * Update some user model fields.
     *
     * Only allowed for authenticated users.
     */
    updateUser?: Maybe<UpdateUserMutationPayload>;
    /**
     * Permanently delete the account.
     *
     * The user must confirm his password.
     *
     * Only allowed for authenticated users.
     */
    deleteUser?: Maybe<DeleteUserMutationPayload>;
    /**
     * Create a new resource.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    createResource?: Maybe<CreateResourceMutationPayload>;
    /**
     * Update a resource.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    updateResource?: Maybe<UpdateResourceMutationPayload>;
    /**
     * Delete a resource.
     *
     * Results are sorted by creation time.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    deleteResource?: Maybe<DeleteResourceMutationPayload>;
    /**
     * Download a resource.
     *
     * This mutation only increments the amount of downloads of a single resource.
     */
    downloadResource?: Maybe<DownloadResourceMutationPayload>;
    /** Email the user with a link to a zip file containing **all** of their data. */
    myData?: Maybe<MyDataMutation>;
    /**
     * Create a new course.
     *
     * Only allowed for authenticated users that have verified their accounts.
     */
    createCourse?: Maybe<CreateCourseMutationPayload>;
    /**
     * Delete a course.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users.
     */
    deleteCourse?: Maybe<DeleteCourseMutationPayload>;
    /** Submit a message via the contact form. */
    createContactMessage?: Maybe<ContactMutationPayload>;
    /**
     * Create a new comment.
     *
     * Attachments are popped of for unauthenticated users. The `user` field must match
     * with the ID of the user making the query to save the user making the query as the
     * author of the comment. This way even authenticated users can create anonymous
     * comments by setting the `user` field as `null`.
     */
    createComment?: Maybe<CreateCommentMutationPayload>;
    /**
     * Update an existing comment.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users.
     */
    updateComment?: Maybe<UpdateCommentMutationPayload>;
    /**
     * Delete a comment.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users.
     */
    deleteComment?: Maybe<DeleteCommentMutationPayload>;
    /**
     * Mark a single activity read/unread.
     *
     * Only allowed for users that are the creators of the object.
     *
     * Only allowed for authenticated users.
     */
    markActivityAsRead?: Maybe<MarkActivityAsReadMutationPayload>;
    /**
     * Mark all activities of the given user as read.
     *
     * Only allowed for authenticated users.
     */
    markAllActivitiesAsRead?: Maybe<MarkAllActivitiesAsReadMutation>;
};
export declare type MutationStarArgs = {
    input: StarMutationInput;
};
export declare type MutationVoteArgs = {
    input: VoteMutationInput;
};
export declare type MutationRegisterArgs = {
    input: RegisterMutationInput;
};
export declare type MutationVerifyAccountArgs = {
    input: VerifyAccountMutationInput;
};
export declare type MutationSendPasswordResetEmailArgs = {
    input: SendPasswordResetEmailMutationInput;
};
export declare type MutationResetPasswordArgs = {
    input: ResetPasswordMutationInput;
};
export declare type MutationLoginArgs = {
    input: LoginMutationInput;
};
export declare type MutationChangePasswordArgs = {
    input: ChangePasswordMutationInput;
};
export declare type MutationUpdateUserArgs = {
    input: UpdateUserMutationInput;
};
export declare type MutationDeleteUserArgs = {
    input: DeleteUserMutationInput;
};
export declare type MutationCreateResourceArgs = {
    input: CreateResourceMutationInput;
};
export declare type MutationUpdateResourceArgs = {
    input: UpdateResourceMutationInput;
};
export declare type MutationDeleteResourceArgs = {
    input: DeleteResourceMutationInput;
};
export declare type MutationDownloadResourceArgs = {
    input: DownloadResourceMutationInput;
};
export declare type MutationCreateCourseArgs = {
    input: CreateCourseMutationInput;
};
export declare type MutationDeleteCourseArgs = {
    input: DeleteCourseMutationInput;
};
export declare type MutationCreateContactMessageArgs = {
    input: ContactMutationInput;
};
export declare type MutationCreateCommentArgs = {
    input: CreateCommentMutationInput;
};
export declare type MutationUpdateCommentArgs = {
    input: UpdateCommentMutationInput;
};
export declare type MutationDeleteCommentArgs = {
    input: DeleteCommentMutationInput;
};
export declare type MutationMarkActivityAsReadArgs = {
    input: MarkActivityAsReadMutationInput;
};
/**
 * Start a course or a resource remove the star if it already exists.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type StarMutationPayload = {
    __typename?: 'StarMutationPayload';
    star?: Maybe<StarObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    starred?: Maybe<Scalars['Boolean']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/** Models a star that a user has placed on a course or a resource. */
export declare type StarObjectType = {
    __typename?: 'StarObjectType';
    id: Scalars['ID'];
    user: UserObjectType;
    course?: Maybe<CourseObjectType>;
    resource?: Maybe<ResourceObjectType>;
};
export declare type ErrorType = {
    __typename?: 'ErrorType';
    field: Scalars['String'];
    messages: Array<Scalars['String']>;
};
export declare type StarMutationInput = {
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Upvote, downvote or remove a vote from a course, resource or a comment.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type VoteMutationPayload = {
    __typename?: 'VoteMutationPayload';
    vote?: Maybe<VoteObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    targetScore?: Maybe<Scalars['Int']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type VoteMutationInput = {
    status: Scalars['Int'];
    comment?: Maybe<Scalars['ID']>;
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Register a new user.
 *
 * Check if there is an existing user with that email or username. Check that account
 * is not deactivated. By default, set the user's account as unverified. After
 * successful registration, send account verification email.
 */
export declare type RegisterMutationPayload = {
    __typename?: 'RegisterMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type RegisterMutationInput = {
    username: Scalars['String'];
    email: Scalars['String'];
    password: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Receive the token that was sent by email.
 *
 * If the token is valid, verify the user's account.
 */
export declare type VerifyAccountMutationPayload = {
    __typename?: 'VerifyAccountMutationPayload';
    token?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type VerifyAccountMutationInput = {
    token?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Send the verification email again.
 *
 * Return an error in the following cases:
 * - A user account with the provided email address was not found.
 * - An unknown error while sending the email occurred.
 * - The user has already verified one's account.
 */
export declare type ResendVerificationEmailMutation = {
    __typename?: 'ResendVerificationEmailMutation';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
};
/**
 * Send password reset email.
 *
 * Return an error in the following cases:
 * - A user account with the provided email address was not found.
 * - An unknown error while sending the email occurred.
 */
export declare type SendPasswordResetEmailMutationPayload = {
    __typename?: 'SendPasswordResetEmailMutationPayload';
    email: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type SendPasswordResetEmailMutationInput = {
    email: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Change user's password without knowing the old password.
 *
 * Receive the token that was sent by email. Revoke refresh token and require the user
 * to log in again with one's new password.
 */
export declare type ResetPasswordMutationPayload = {
    __typename?: 'ResetPasswordMutationPayload';
    token?: Maybe<Scalars['String']>;
    newPassword: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type ResetPasswordMutationInput = {
    token?: Maybe<Scalars['String']>;
    newPassword: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Obtain JSON web token and user information.
 *
 * Non-verified users can still login.
 */
export declare type LoginMutationPayload = {
    __typename?: 'LoginMutationPayload';
    user?: Maybe<UserObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type LoginMutationInput = {
    usernameOrEmail: Scalars['String'];
    password: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete JSON web token cookie and logout.
 *
 * This sets the `Set-Cookie` header so that the JWT token cookie gets automatically
 * deleted in frontend.
 */
export declare type LogoutMutation = {
    __typename?: 'LogoutMutation';
    deleted: Scalars['Boolean'];
};
/**
 * Change password with a requirement of knowing the old password.
 *
 * Only allowed for authenticated users.
 */
export declare type ChangePasswordMutationPayload = {
    __typename?: 'ChangePasswordMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type ChangePasswordMutationInput = {
    oldPassword: Scalars['String'];
    newPassword: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Update some user model fields.
 *
 * Only allowed for authenticated users.
 */
export declare type UpdateUserMutationPayload = {
    __typename?: 'UpdateUserMutationPayload';
    user?: Maybe<UserObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateUserMutationInput = {
    username: Scalars['String'];
    email: Scalars['String'];
    title?: Maybe<Scalars['String']>;
    bio?: Maybe<Scalars['String']>;
    avatar?: Maybe<Scalars['String']>;
    school?: Maybe<Scalars['ID']>;
    subject?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Permanently delete the account.
 *
 * The user must confirm his password.
 *
 * Only allowed for authenticated users.
 */
export declare type DeleteUserMutationPayload = {
    __typename?: 'DeleteUserMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteUserMutationInput = {
    password: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Create a new resource.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type CreateResourceMutationPayload = {
    __typename?: 'CreateResourceMutationPayload';
    resource?: Maybe<ResourceObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type CreateResourceMutationInput = {
    title: Scalars['String'];
    file: Scalars['String'];
    resourceType: Scalars['ID'];
    course: Scalars['ID'];
    date?: Maybe<Scalars['Date']>;
    author?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Update a resource.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type UpdateResourceMutationPayload = {
    __typename?: 'UpdateResourceMutationPayload';
    resource?: Maybe<ResourceObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateResourceMutationInput = {
    title: Scalars['String'];
    resourceType: Scalars['ID'];
    date?: Maybe<Scalars['Date']>;
    author?: Maybe<Scalars['String']>;
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete a resource.
 *
 * Results are sorted by creation time.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type DeleteResourceMutationPayload = {
    __typename?: 'DeleteResourceMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteResourceMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Download a resource.
 *
 * This mutation only increments the amount of downloads of a single resource.
 */
export declare type DownloadResourceMutationPayload = {
    __typename?: 'DownloadResourceMutationPayload';
    resource?: Maybe<ResourceObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DownloadResourceMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/** Email the user with a link to a zip file containing **all** of their data. */
export declare type MyDataMutation = {
    __typename?: 'MyDataMutation';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
};
/**
 * Create a new course.
 *
 * Only allowed for authenticated users that have verified their accounts.
 */
export declare type CreateCourseMutationPayload = {
    __typename?: 'CreateCourseMutationPayload';
    course?: Maybe<CourseObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type CreateCourseMutationInput = {
    name: Scalars['String'];
    code?: Maybe<Scalars['String']>;
    subjects?: Maybe<Array<Maybe<Scalars['ID']>>>;
    school: Scalars['ID'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete a course.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users.
 */
export declare type DeleteCourseMutationPayload = {
    __typename?: 'DeleteCourseMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteCourseMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/** Submit a message via the contact form. */
export declare type ContactMutationPayload = {
    __typename?: 'ContactMutationPayload';
    subject?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
    message: Scalars['String'];
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type ContactMutationInput = {
    subject?: Maybe<Scalars['String']>;
    name?: Maybe<Scalars['String']>;
    email?: Maybe<Scalars['String']>;
    message: Scalars['String'];
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Create a new comment.
 *
 * Attachments are popped of for unauthenticated users. The `user` field must match
 * with the ID of the user making the query to save the user making the query as the
 * author of the comment. This way even authenticated users can create anonymous
 * comments by setting the `user` field as `null`.
 */
export declare type CreateCommentMutationPayload = {
    __typename?: 'CreateCommentMutationPayload';
    comment?: Maybe<CommentObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type CreateCommentMutationInput = {
    text?: Maybe<Scalars['String']>;
    attachment?: Maybe<Scalars['String']>;
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
    comment?: Maybe<Scalars['ID']>;
    school?: Maybe<Scalars['ID']>;
    user?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Update an existing comment.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users.
 */
export declare type UpdateCommentMutationPayload = {
    __typename?: 'UpdateCommentMutationPayload';
    comment?: Maybe<CommentObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    successMessage?: Maybe<Scalars['String']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type UpdateCommentMutationInput = {
    text?: Maybe<Scalars['String']>;
    attachment?: Maybe<Scalars['String']>;
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Delete a comment.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users.
 */
export declare type DeleteCommentMutationPayload = {
    __typename?: 'DeleteCommentMutationPayload';
    successMessage?: Maybe<Scalars['String']>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type DeleteCommentMutationInput = {
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Mark a single activity read/unread.
 *
 * Only allowed for users that are the creators of the object.
 *
 * Only allowed for authenticated users.
 */
export declare type MarkActivityAsReadMutationPayload = {
    __typename?: 'MarkActivityAsReadMutationPayload';
    activity?: Maybe<ActivityObjectType>;
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    clientMutationId?: Maybe<Scalars['String']>;
};
export declare type MarkActivityAsReadMutationInput = {
    read?: Maybe<Scalars['Boolean']>;
    id?: Maybe<Scalars['ID']>;
    clientMutationId?: Maybe<Scalars['String']>;
};
/**
 * Mark all activities of the given user as read.
 *
 * Only allowed for authenticated users.
 */
export declare type MarkAllActivitiesAsReadMutation = {
    __typename?: 'MarkAllActivitiesAsReadMutation';
    errors?: Maybe<Array<Maybe<ErrorType>>>;
    activities?: Maybe<PaginatedActivityObjectType>;
};
export declare type ActivitiesQueryVariables = Exact<{
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type ActivitiesQuery = ({
    __typename?: 'Query';
} & {
    activities?: Maybe<({
        __typename?: 'PaginatedActivityObjectType';
    } & Pick<PaginatedActivityObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'ActivityObjectType';
        } & Pick<ActivityObjectType, 'id' | 'description' | 'read'> & {
            targetUser?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
            course?: Maybe<({
                __typename?: 'CourseObjectType';
            } & Pick<CourseObjectType, 'id'>)>;
            resource?: Maybe<({
                __typename?: 'ResourceObjectType';
            } & Pick<ResourceObjectType, 'id'>)>;
            comment?: Maybe<({
                __typename?: 'CommentObjectType';
            } & Pick<CommentObjectType, 'id'>)>;
        })>>>;
    })>;
});
export declare type ActivityPreviewQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type ActivityPreviewQuery = ({
    __typename?: 'Query';
} & {
    activityPreview?: Maybe<Array<Maybe<({
        __typename?: 'ActivityObjectType';
    } & Pick<ActivityObjectType, 'id' | 'description' | 'read'> & {
        targetUser?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
        course?: Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id'>)>;
        resource?: Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id'>)>;
        comment?: Maybe<({
            __typename?: 'CommentObjectType';
        } & Pick<CommentObjectType, 'id'>)>;
    })>>>;
});
export declare type MarkActivityAsReadMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
    read?: Maybe<Scalars['Boolean']>;
}>;
export declare type MarkActivityAsReadMutation = ({
    __typename?: 'Mutation';
} & {
    markActivityAsRead?: Maybe<({
        __typename?: 'MarkActivityAsReadMutationPayload';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        activity?: Maybe<({
            __typename?: 'ActivityObjectType';
        } & Pick<ActivityObjectType, 'id' | 'description' | 'read'> & {
            targetUser?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
            course?: Maybe<({
                __typename?: 'CourseObjectType';
            } & Pick<CourseObjectType, 'id'>)>;
            resource?: Maybe<({
                __typename?: 'ResourceObjectType';
            } & Pick<ResourceObjectType, 'id'>)>;
            comment?: Maybe<({
                __typename?: 'CommentObjectType';
            } & Pick<CommentObjectType, 'id'>)>;
        })>;
    })>;
});
export declare type GraphQlMarkAllActivitiesAsReadMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlMarkAllActivitiesAsReadMutation = ({
    __typename?: 'Mutation';
} & {
    markAllActivitiesAsRead?: Maybe<({
        __typename?: 'MarkAllActivitiesAsReadMutation';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
        activities?: Maybe<({
            __typename?: 'PaginatedActivityObjectType';
        } & Pick<PaginatedActivityObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
            objects?: Maybe<Array<Maybe<({
                __typename?: 'ActivityObjectType';
            } & Pick<ActivityObjectType, 'id' | 'description' | 'read'> & {
                targetUser?: Maybe<({
                    __typename?: 'UserObjectType';
                } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
                course?: Maybe<({
                    __typename?: 'CourseObjectType';
                } & Pick<CourseObjectType, 'id'>)>;
                resource?: Maybe<({
                    __typename?: 'ResourceObjectType';
                } & Pick<ResourceObjectType, 'id'>)>;
                comment?: Maybe<({
                    __typename?: 'CommentObjectType';
                } & Pick<CommentObjectType, 'id'>)>;
            })>>>;
        })>;
    })>;
});
export declare type AutocompleteCitiesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AutocompleteCitiesQuery = ({
    __typename?: 'Query';
} & {
    autocompleteCities?: Maybe<Array<Maybe<({
        __typename?: 'CityObjectType';
    } & Pick<CityObjectType, 'id' | 'name'>)>>>;
});
export declare type CreateCommentMutationVariables = Exact<{
    user?: Maybe<Scalars['String']>;
    text: Scalars['String'];
    attachment?: Maybe<Scalars['String']>;
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
    comment?: Maybe<Scalars['ID']>;
    school?: Maybe<Scalars['ID']>;
}>;
export declare type CreateCommentMutation = ({
    __typename?: 'Mutation';
} & {
    createComment?: Maybe<({
        __typename?: 'CreateCommentMutationPayload';
    } & Pick<CreateCommentMutationPayload, 'successMessage'> & {
        comment?: Maybe<({
            __typename?: 'CommentObjectType';
        } & Pick<CommentObjectType, 'id'> & {
            course?: Maybe<({
                __typename?: 'CourseObjectType';
            } & Pick<CourseObjectType, 'id'>)>;
            resource?: Maybe<({
                __typename?: 'ResourceObjectType';
            } & Pick<ResourceObjectType, 'id'>)>;
            school?: Maybe<({
                __typename?: 'SchoolObjectType';
            } & Pick<SchoolObjectType, 'id'>)>;
        })>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type DeleteCommentMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type DeleteCommentMutation = ({
    __typename?: 'Mutation';
} & {
    deleteComment?: Maybe<({
        __typename?: 'DeleteCommentMutationPayload';
    } & Pick<DeleteCommentMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type CreateContactMessageMutationVariables = Exact<{
    subject: Scalars['String'];
    name?: Maybe<Scalars['String']>;
    email: Scalars['String'];
    message: Scalars['String'];
}>;
export declare type CreateContactMessageMutation = ({
    __typename?: 'Mutation';
} & {
    createContactMessage?: Maybe<({
        __typename?: 'ContactMutationPayload';
    } & Pick<ContactMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type AutocompleteCountriesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AutocompleteCountriesQuery = ({
    __typename?: 'Query';
} & {
    autocompleteCountries?: Maybe<Array<Maybe<({
        __typename?: 'CountryObjectType';
    } & Pick<CountryObjectType, 'id' | 'name'>)>>>;
});
export declare type CoursesQueryVariables = Exact<{
    searchTerm?: Maybe<Scalars['String']>;
    school?: Maybe<Scalars['ID']>;
    subject?: Maybe<Scalars['ID']>;
    schoolType?: Maybe<Scalars['ID']>;
    country?: Maybe<Scalars['ID']>;
    city?: Maybe<Scalars['ID']>;
    ordering?: Maybe<Scalars['String']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type CoursesQuery = ({
    __typename?: 'Query';
} & {
    courses?: Maybe<({
        __typename?: 'PaginatedCourseObjectType';
    } & Pick<PaginatedCourseObjectType, 'page' | 'pages' | 'hasPrev' | 'hasNext' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'score' | 'starCount' | 'resourceCount' | 'commentCount' | 'created'> & {
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username'>)>;
        })>>>;
    })>;
    school?: Maybe<({
        __typename?: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'id' | 'name'>)>;
    subject?: Maybe<({
        __typename?: 'SubjectObjectType';
    } & Pick<SubjectObjectType, 'id' | 'name'>)>;
    schoolType?: Maybe<({
        __typename?: 'SchoolTypeObjectType';
    } & Pick<SchoolTypeObjectType, 'id' | 'name'>)>;
    country?: Maybe<({
        __typename?: 'CountryObjectType';
    } & Pick<CountryObjectType, 'id' | 'name'>)>;
    city?: Maybe<({
        __typename?: 'CityObjectType';
    } & Pick<CityObjectType, 'id' | 'name'>)>;
});
export declare type CourseQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type CourseQuery = ({
    __typename?: 'Query';
} & {
    course?: Maybe<({
        __typename?: 'CourseObjectType';
    } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'modified' | 'created' | 'score' | 'starred' | 'starCount' | 'commentCount'> & {
        vote?: Maybe<({
            __typename?: 'VoteObjectType';
        } & Pick<VoteObjectType, 'id' | 'status'>)>;
        subjects: Array<({
            __typename?: 'SubjectObjectType';
        } & Pick<SubjectObjectType, 'id' | 'name'>)>;
        school: ({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>);
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
    })>;
    resources?: Maybe<({
        __typename?: 'PaginatedResourceObjectType';
    } & Pick<PaginatedResourceObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id' | 'title' | 'score' | 'date' | 'starCount' | 'commentCount' | 'downloads' | 'created'> & {
            resourceType?: Maybe<({
                __typename?: 'ResourceTypeObjectType';
            } & Pick<ResourceTypeObjectType, 'name'>)>;
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username'>)>;
        })>>>;
    })>;
});
export declare type CourseSeoPropsQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type CourseSeoPropsQuery = ({
    __typename?: 'Query';
} & {
    course?: Maybe<({
        __typename?: 'CourseObjectType';
    } & Pick<CourseObjectType, 'name' | 'code'>)>;
});
export declare type CreateCourseAutocompleteDataQueryVariables = Exact<{
    school?: Maybe<Scalars['ID']>;
}>;
export declare type CreateCourseAutocompleteDataQuery = ({
    __typename?: 'Query';
} & {
    school?: Maybe<({
        __typename?: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'id' | 'name'>)>;
});
export declare type AutocompleteCoursesQueryVariables = Exact<{
    school?: Maybe<Scalars['ID']>;
    name?: Maybe<Scalars['String']>;
}>;
export declare type AutocompleteCoursesQuery = ({
    __typename?: 'Query';
} & {
    autocompleteCourses?: Maybe<Array<Maybe<({
        __typename?: 'CourseObjectType';
    } & Pick<CourseObjectType, 'id' | 'name' | 'code'>)>>>;
});
export declare type CreateCourseMutationVariables = Exact<{
    courseName: Scalars['String'];
    courseCode?: Maybe<Scalars['String']>;
    subjects?: Maybe<Array<Maybe<Scalars['ID']>> | Maybe<Scalars['ID']>>;
    school: Scalars['ID'];
}>;
export declare type CreateCourseMutation = ({
    __typename?: 'Mutation';
} & {
    createCourse?: Maybe<({
        __typename?: 'CreateCourseMutationPayload';
    } & Pick<CreateCourseMutationPayload, 'successMessage'> & {
        course?: Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id'>)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type DeleteCourseMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type DeleteCourseMutation = ({
    __typename?: 'Mutation';
} & {
    deleteCourse?: Maybe<({
        __typename?: 'DeleteCourseMutationPayload';
    } & Pick<DeleteCourseMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type ResourceQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type ResourceQuery = ({
    __typename?: 'Query';
} & {
    resource?: Maybe<({
        __typename?: 'ResourceObjectType';
    } & Pick<ResourceObjectType, 'id' | 'title' | 'file' | 'date' | 'modified' | 'created' | 'score' | 'starred' | 'starCount' | 'downloads' | 'commentCount'> & {
        resourceType?: Maybe<({
            __typename?: 'ResourceTypeObjectType';
        } & Pick<ResourceTypeObjectType, 'id' | 'name'>)>;
        school?: Maybe<({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>)>;
        course: ({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name'>);
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
        vote?: Maybe<({
            __typename?: 'VoteObjectType';
        } & Pick<VoteObjectType, 'id' | 'status'>)>;
    })>;
});
export declare type ResourceSeoPropsQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type ResourceSeoPropsQuery = ({
    __typename?: 'Query';
} & {
    resource?: Maybe<({
        __typename?: 'ResourceObjectType';
    } & Pick<ResourceObjectType, 'title' | 'date'>)>;
});
export declare type CreateResourceAutocompleteDataQueryVariables = Exact<{
    school?: Maybe<Scalars['ID']>;
    course?: Maybe<Scalars['ID']>;
}>;
export declare type CreateResourceAutocompleteDataQuery = ({
    __typename?: 'Query';
} & {
    school?: Maybe<({
        __typename?: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'id' | 'name'>)>;
    course?: Maybe<({
        __typename?: 'CourseObjectType';
    } & Pick<CourseObjectType, 'id' | 'name' | 'code'>)>;
});
export declare type AutocompleteResourceTypesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AutocompleteResourceTypesQuery = ({
    __typename?: 'Query';
} & {
    autocompleteResourceTypes?: Maybe<Array<Maybe<({
        __typename?: 'ResourceTypeObjectType';
    } & Pick<ResourceTypeObjectType, 'id' | 'name'>)>>>;
});
export declare type CreateResourceMutationVariables = Exact<{
    resourceTitle: Scalars['String'];
    resourceType: Scalars['ID'];
    date?: Maybe<Scalars['Date']>;
    course: Scalars['ID'];
    file: Scalars['String'];
}>;
export declare type CreateResourceMutation = ({
    __typename?: 'Mutation';
} & {
    createResource?: Maybe<({
        __typename?: 'CreateResourceMutationPayload';
    } & Pick<CreateResourceMutationPayload, 'successMessage'> & {
        resource?: Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id'>)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type DeleteResourceMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type DeleteResourceMutation = ({
    __typename?: 'Mutation';
} & {
    deleteResource?: Maybe<({
        __typename?: 'DeleteResourceMutationPayload';
    } & Pick<DeleteResourceMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type DownloadResourceMutationVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type DownloadResourceMutation = ({
    __typename?: 'Mutation';
} & {
    downloadResource?: Maybe<({
        __typename?: 'DownloadResourceMutationPayload';
    } & {
        resource?: Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'downloads'>)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type SchoolQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type SchoolQuery = ({
    __typename?: 'Query';
} & {
    school?: Maybe<({
        __typename?: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'id' | 'name' | 'commentCount'> & {
        city?: Maybe<({
            __typename?: 'CityObjectType';
        } & Pick<CityObjectType, 'id' | 'name'>)>;
        country?: Maybe<({
            __typename?: 'CountryObjectType';
        } & Pick<CountryObjectType, 'id' | 'name'>)>;
        schoolType?: Maybe<({
            __typename?: 'SchoolTypeObjectType';
        } & Pick<SchoolTypeObjectType, 'id' | 'name'>)>;
    })>;
    subjects?: Maybe<({
        __typename?: 'PaginatedSubjectObjectType';
    } & Pick<PaginatedSubjectObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'SubjectObjectType';
        } & Pick<SubjectObjectType, 'id' | 'name' | 'courseCount' | 'resourceCount'>)>>>;
    })>;
    courses?: Maybe<({
        __typename?: 'PaginatedCourseObjectType';
    } & Pick<PaginatedCourseObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'score' | 'starCount' | 'resourceCount' | 'commentCount'> & {
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username'>)>;
        })>>>;
    })>;
});
export declare type SchoolSeoPropsQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type SchoolSeoPropsQuery = ({
    __typename?: 'Query';
} & {
    school?: Maybe<({
        __typename?: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'name'>)>;
});
export declare type AutocompleteSchoolsQueryVariables = Exact<{
    name?: Maybe<Scalars['String']>;
}>;
export declare type AutocompleteSchoolsQuery = ({
    __typename?: 'Query';
} & {
    autocompleteSchools?: Maybe<Array<Maybe<({
        __typename?: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'id' | 'name'>)>>>;
});
export declare type AutocompleteSchoolTypesQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type AutocompleteSchoolTypesQuery = ({
    __typename?: 'Query';
} & {
    autocompleteSchoolTypes?: Maybe<Array<Maybe<({
        __typename?: 'SchoolTypeObjectType';
    } & Pick<SchoolTypeObjectType, 'id' | 'name'>)>>>;
});
export declare type StarredQueryVariables = Exact<{
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type StarredQuery = ({
    __typename?: 'Query';
} & {
    starredCourses?: Maybe<({
        __typename?: 'PaginatedCourseObjectType';
    } & Pick<PaginatedCourseObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'score' | 'starCount' | 'resourceCount' | 'commentCount'> & {
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username'>)>;
        })>>>;
    })>;
    starredResources?: Maybe<({
        __typename?: 'PaginatedResourceObjectType';
    } & Pick<PaginatedResourceObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id' | 'title' | 'score' | 'date' | 'starCount' | 'commentCount' | 'downloads'> & {
            course: ({
                __typename?: 'CourseObjectType';
            } & Pick<CourseObjectType, 'name' | 'code'>);
            resourceType?: Maybe<({
                __typename?: 'ResourceTypeObjectType';
            } & Pick<ResourceTypeObjectType, 'name'>)>;
        })>>>;
    })>;
});
export declare type StarMutationVariables = Exact<{
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
}>;
export declare type StarMutation = ({
    __typename?: 'Mutation';
} & {
    star?: Maybe<({
        __typename?: 'StarMutationPayload';
    } & Pick<StarMutationPayload, 'starred'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type AutocompleteSubjectsQueryVariables = Exact<{
    name?: Maybe<Scalars['String']>;
}>;
export declare type AutocompleteSubjectsQuery = ({
    __typename?: 'Query';
} & {
    autocompleteSubjects?: Maybe<Array<Maybe<({
        __typename?: 'SubjectObjectType';
    } & Pick<SubjectObjectType, 'id' | 'name'>)>>>;
});
export declare type UserMeQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type UserMeQuery = ({
    __typename?: 'Query';
} & {
    userMe?: Maybe<({
        __typename?: 'UserObjectType';
    } & Pick<UserObjectType, 'id' | 'username' | 'email' | 'title' | 'bio' | 'avatar' | 'avatarThumbnail' | 'score' | 'created' | 'verified' | 'unreadActivityCount' | 'rank'> & {
        school?: Maybe<({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>)>;
        subject?: Maybe<({
            __typename?: 'SubjectObjectType';
        } & Pick<SubjectObjectType, 'id' | 'name'>)>;
    })>;
});
export declare type UserQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
    page?: Maybe<Scalars['Int']>;
    pageSize?: Maybe<Scalars['Int']>;
}>;
export declare type UserQuery = ({
    __typename?: 'Query';
} & {
    user?: Maybe<({
        __typename?: 'UserObjectType';
    } & Pick<UserObjectType, 'id' | 'username' | 'title' | 'bio' | 'avatar' | 'score' | 'created' | 'verified' | 'rank'> & {
        badges?: Maybe<Array<Maybe<({
            __typename?: 'BadgeObjectType';
        } & Pick<BadgeObjectType, 'id' | 'name' | 'description'>)>>>;
    })>;
    courses?: Maybe<({
        __typename?: 'PaginatedCourseObjectType';
    } & Pick<PaginatedCourseObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'score' | 'starCount' | 'resourceCount' | 'commentCount' | 'created'> & {
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username'>)>;
        })>>>;
    })>;
    resources?: Maybe<({
        __typename?: 'PaginatedResourceObjectType';
    } & Pick<PaginatedResourceObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id' | 'title' | 'score' | 'date' | 'starCount' | 'commentCount' | 'downloads' | 'created'> & {
            course: ({
                __typename?: 'CourseObjectType';
            } & Pick<CourseObjectType, 'name' | 'code'>);
            resourceType?: Maybe<({
                __typename?: 'ResourceTypeObjectType';
            } & Pick<ResourceTypeObjectType, 'name'>)>;
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username'>)>;
        })>>>;
    })>;
    comments?: Maybe<({
        __typename?: 'PaginatedCommentObjectType';
    } & Pick<PaginatedCommentObjectType, 'page' | 'pages' | 'hasNext' | 'hasPrev' | 'count'> & {
        objects?: Maybe<Array<Maybe<({
            __typename?: 'CommentObjectType';
        } & Pick<CommentObjectType, 'id' | 'text' | 'attachment' | 'created' | 'score' | 'replyCount'> & {
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
            course?: Maybe<({
                __typename?: 'CourseObjectType';
            } & Pick<CourseObjectType, 'id' | 'name'>)>;
            resource?: Maybe<({
                __typename?: 'ResourceObjectType';
            } & Pick<ResourceObjectType, 'id' | 'title'>)>;
            comment?: Maybe<({
                __typename?: 'CommentObjectType';
            } & {
                course?: Maybe<({
                    __typename?: 'CourseObjectType';
                } & Pick<CourseObjectType, 'id'>)>;
                resource?: Maybe<({
                    __typename?: 'ResourceObjectType';
                } & Pick<ResourceObjectType, 'id'>)>;
            })>;
        })>>>;
    })>;
});
export declare type UserSeoPropsQueryVariables = Exact<{
    id?: Maybe<Scalars['ID']>;
}>;
export declare type UserSeoPropsQuery = ({
    __typename?: 'Query';
} & {
    user?: Maybe<({
        __typename?: 'UserObjectType';
    } & Pick<UserObjectType, 'username'>)>;
});
export declare type RegisterMutationVariables = Exact<{
    username: Scalars['String'];
    email: Scalars['String'];
    password: Scalars['String'];
}>;
export declare type RegisterMutation = ({
    __typename?: 'Mutation';
} & {
    register?: Maybe<({
        __typename?: 'RegisterMutationPayload';
    } & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
    login?: Maybe<({
        __typename?: 'LoginMutationPayload';
    } & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'username' | 'email'>)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type LoginMutationVariables = Exact<{
    usernameOrEmail: Scalars['String'];
    password: Scalars['String'];
}>;
export declare type LoginMutation = ({
    __typename?: 'Mutation';
} & {
    login?: Maybe<({
        __typename?: 'LoginMutationPayload';
    } & Pick<LoginMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type GraphQlLogoutMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlLogoutMutation = ({
    __typename?: 'Mutation';
} & {
    logout?: Maybe<({
        __typename?: 'LogoutMutation';
    } & Pick<LogoutMutation, 'deleted'>)>;
});
export declare type GraphQlResendVerificationEmailMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlResendVerificationEmailMutation = ({
    __typename?: 'Mutation';
} & {
    resendVerificationEmail?: Maybe<({
        __typename?: 'ResendVerificationEmailMutation';
    } & Pick<ResendVerificationEmailMutation, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type GraphQlMyDataMutationVariables = Exact<{
    [key: string]: never;
}>;
export declare type GraphQlMyDataMutation = ({
    __typename?: 'Mutation';
} & {
    myData?: Maybe<({
        __typename?: 'MyDataMutation';
    } & Pick<MyDataMutation, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type VerifyAccountMutationVariables = Exact<{
    token?: Maybe<Scalars['String']>;
}>;
export declare type VerifyAccountMutation = ({
    __typename?: 'Mutation';
} & {
    verifyAccount?: Maybe<({
        __typename?: 'VerifyAccountMutationPayload';
    } & Pick<VerifyAccountMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type SendPasswordResetEmailMutationVariables = Exact<{
    email: Scalars['String'];
}>;
export declare type SendPasswordResetEmailMutation = ({
    __typename?: 'Mutation';
} & {
    sendPasswordResetEmail?: Maybe<({
        __typename?: 'SendPasswordResetEmailMutationPayload';
    } & Pick<SendPasswordResetEmailMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type ResetPasswordMutationVariables = Exact<{
    token?: Maybe<Scalars['String']>;
    newPassword: Scalars['String'];
}>;
export declare type ResetPasswordMutation = ({
    __typename?: 'Mutation';
} & {
    resetPassword?: Maybe<({
        __typename?: 'ResetPasswordMutationPayload';
    } & Pick<ResetPasswordMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type UpdateUserMutationVariables = Exact<{
    username: Scalars['String'];
    email: Scalars['String'];
    title?: Maybe<Scalars['String']>;
    bio?: Maybe<Scalars['String']>;
    avatar?: Maybe<Scalars['String']>;
    school?: Maybe<Scalars['ID']>;
    subject?: Maybe<Scalars['ID']>;
}>;
export declare type UpdateUserMutation = ({
    __typename?: 'Mutation';
} & {
    updateUser?: Maybe<({
        __typename?: 'UpdateUserMutationPayload';
    } & Pick<UpdateUserMutationPayload, 'successMessage'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username' | 'avatar' | 'avatarThumbnail' | 'email' | 'title' | 'bio' | 'score' | 'created'>)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type ChangePasswordMutationVariables = Exact<{
    oldPassword: Scalars['String'];
    newPassword: Scalars['String'];
}>;
export declare type ChangePasswordMutation = ({
    __typename?: 'Mutation';
} & {
    changePassword?: Maybe<({
        __typename?: 'ChangePasswordMutationPayload';
    } & Pick<ChangePasswordMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type DeleteUserMutationVariables = Exact<{
    password: Scalars['String'];
}>;
export declare type DeleteUserMutation = ({
    __typename?: 'Mutation';
} & {
    deleteUser?: Maybe<({
        __typename?: 'DeleteUserMutationPayload';
    } & Pick<DeleteUserMutationPayload, 'successMessage'> & {
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type VoteMutationVariables = Exact<{
    status: Scalars['Int'];
    comment?: Maybe<Scalars['ID']>;
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
}>;
export declare type VoteMutation = ({
    __typename?: 'Mutation';
} & {
    vote?: Maybe<({
        __typename?: 'VoteMutationPayload';
    } & Pick<VoteMutationPayload, 'targetScore'> & {
        vote?: Maybe<({
            __typename?: 'VoteObjectType';
        } & Pick<VoteObjectType, 'id' | 'status'>)>;
        errors?: Maybe<Array<Maybe<({
            __typename?: 'ErrorType';
        } & Pick<ErrorType, 'field' | 'messages'>)>>>;
    })>;
});
export declare type SitemapQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type SitemapQuery = ({
    __typename?: 'Query';
} & {
    sitemap?: Maybe<({
        __typename?: 'SitemapObjectType';
    } & {
        courses: Array<({
            __typename?: 'SitemapEntryObjectType';
        } & Pick<SitemapEntryObjectType, 'id' | 'modified'>)>;
        resources: Array<({
            __typename?: 'SitemapEntryObjectType';
        } & Pick<SitemapEntryObjectType, 'id' | 'modified'>)>;
        schools: Array<({
            __typename?: 'SitemapEntryObjectType';
        } & Pick<SitemapEntryObjectType, 'id' | 'modified'>)>;
        users: Array<({
            __typename?: 'SitemapEntryObjectType';
        } & Pick<SitemapEntryObjectType, 'id' | 'modified'>)>;
    })>;
});
export declare type SuggestionsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type SuggestionsQuery = ({
    __typename?: 'Query';
} & {
    suggestions?: Maybe<Array<Maybe<({
        __typename?: 'CourseObjectType';
    } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'score' | 'starCount' | 'resourceCount' | 'commentCount' | 'created'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
    }) | ({
        __typename?: 'ResourceObjectType';
    } & Pick<ResourceObjectType, 'id' | 'title' | 'score' | 'date' | 'starCount' | 'commentCount' | 'downloads' | 'created'> & {
        resourceType?: Maybe<({
            __typename?: 'ResourceTypeObjectType';
        } & Pick<ResourceTypeObjectType, 'name'>)>;
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
        course: ({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'name' | 'code'>);
    }) | ({
        __typename?: 'CommentObjectType';
    } & Pick<CommentObjectType, 'id' | 'text' | 'attachmentThumbnail' | 'created' | 'score' | 'replyCount'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
        commentCourse?: Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name'>)>;
        resource?: Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id' | 'title'>)>;
        school?: Maybe<({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>)>;
    })>>>;
});
export declare type SuggestionsPreviewQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type SuggestionsPreviewQuery = ({
    __typename?: 'Query';
} & {
    suggestionsPreview?: Maybe<Array<Maybe<({
        __typename?: 'CourseObjectType';
    } & Pick<CourseObjectType, 'id' | 'name' | 'code' | 'score' | 'starCount' | 'resourceCount' | 'commentCount' | 'created'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
    }) | ({
        __typename?: 'ResourceObjectType';
    } & Pick<ResourceObjectType, 'id' | 'title' | 'score' | 'starCount' | 'commentCount' | 'downloads' | 'created'> & {
        resourceType?: Maybe<({
            __typename?: 'ResourceTypeObjectType';
        } & Pick<ResourceTypeObjectType, 'name'>)>;
        course: ({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'name' | 'code'>);
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
    }) | ({
        __typename?: 'CommentObjectType';
    } & Pick<CommentObjectType, 'id' | 'text' | 'attachmentThumbnail' | 'created' | 'score' | 'replyCount'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username'>)>;
        commentCourse?: Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name'>)>;
        resource?: Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id' | 'title'>)>;
        school?: Maybe<({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>)>;
    })>>>;
});
export declare type DiscussionQueryVariables = Exact<{
    course?: Maybe<Scalars['ID']>;
    resource?: Maybe<Scalars['ID']>;
    school?: Maybe<Scalars['ID']>;
}>;
export declare type DiscussionQuery = ({
    __typename?: 'Query';
} & {
    discussion?: Maybe<Array<Maybe<({
        __typename?: 'CommentObjectType';
    } & Pick<CommentObjectType, 'id' | 'text' | 'attachment' | 'attachmentThumbnail' | 'created' | 'score'> & {
        user?: Maybe<({
            __typename?: 'UserObjectType';
        } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
        vote?: Maybe<({
            __typename?: 'VoteObjectType';
        } & Pick<VoteObjectType, 'id' | 'status'>)>;
        course?: Maybe<({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name'>)>;
        resource?: Maybe<({
            __typename?: 'ResourceObjectType';
        } & Pick<ResourceObjectType, 'id' | 'title'>)>;
        school?: Maybe<({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>)>;
        replyComments: Array<({
            __typename?: 'CommentObjectType';
        } & Pick<CommentObjectType, 'id' | 'text' | 'attachment' | 'attachmentThumbnail' | 'created' | 'score'> & {
            user?: Maybe<({
                __typename?: 'UserObjectType';
            } & Pick<UserObjectType, 'id' | 'username' | 'avatarThumbnail'>)>;
            vote?: Maybe<({
                __typename?: 'VoteObjectType';
            } & Pick<VoteObjectType, 'id' | 'status'>)>;
        })>;
    })>>>;
});
export declare type DiscussionSuggestionsQueryVariables = Exact<{
    [key: string]: never;
}>;
export declare type DiscussionSuggestionsQuery = ({
    __typename?: 'Query';
} & {
    discussionSuggestions?: Maybe<Array<Maybe<({
        __typename: 'CourseObjectType';
    } & Pick<CourseObjectType, 'id' | 'code'> & {
        courseName: CourseObjectType['name'];
    } & {
        school: ({
            __typename?: 'SchoolObjectType';
        } & Pick<SchoolObjectType, 'id' | 'name'>);
    }) | ({
        __typename: 'ResourceObjectType';
    } & Pick<ResourceObjectType, 'id' | 'title'> & {
        course: ({
            __typename?: 'CourseObjectType';
        } & Pick<CourseObjectType, 'id' | 'name'>);
    }) | ({
        __typename: 'SchoolObjectType';
    } & Pick<SchoolObjectType, 'id' | 'name'>)>>>;
});
export declare const ActivitiesDocument: Apollo.DocumentNode;
/**
 * __useActivitiesQuery__
 *
 * To run a query within a React component, call `useActivitiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivitiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivitiesQuery({
 *   variables: {
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useActivitiesQuery(baseOptions?: Apollo.QueryHookOptions<ActivitiesQuery, ActivitiesQueryVariables>): Apollo.QueryResult<ActivitiesQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useActivitiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivitiesQuery, ActivitiesQueryVariables>): Apollo.QueryTuple<ActivitiesQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type ActivitiesQueryHookResult = ReturnType<typeof useActivitiesQuery>;
export declare type ActivitiesLazyQueryHookResult = ReturnType<typeof useActivitiesLazyQuery>;
export declare type ActivitiesQueryResult = Apollo.QueryResult<ActivitiesQuery, ActivitiesQueryVariables>;
export declare const ActivityPreviewDocument: Apollo.DocumentNode;
/**
 * __useActivityPreviewQuery__
 *
 * To run a query within a React component, call `useActivityPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useActivityPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useActivityPreviewQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useActivityPreviewQuery(baseOptions?: Apollo.QueryHookOptions<ActivityPreviewQuery, ActivityPreviewQueryVariables>): Apollo.QueryResult<ActivityPreviewQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useActivityPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ActivityPreviewQuery, ActivityPreviewQueryVariables>): Apollo.QueryTuple<ActivityPreviewQuery, Exact<{
    [key: string]: never;
}>>;
export declare type ActivityPreviewQueryHookResult = ReturnType<typeof useActivityPreviewQuery>;
export declare type ActivityPreviewLazyQueryHookResult = ReturnType<typeof useActivityPreviewLazyQuery>;
export declare type ActivityPreviewQueryResult = Apollo.QueryResult<ActivityPreviewQuery, ActivityPreviewQueryVariables>;
export declare const MarkActivityAsReadDocument: Apollo.DocumentNode;
export declare type MarkActivityAsReadMutationFn = Apollo.MutationFunction<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>;
/**
 * __useMarkActivityAsReadMutation__
 *
 * To run a mutation, you first call `useMarkActivityAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMarkActivityAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [markActivityAsReadMutation, { data, loading, error }] = useMarkActivityAsReadMutation({
 *   variables: {
 *      id: // value for 'id'
 *      read: // value for 'read'
 *   },
 * });
 */
export declare function useMarkActivityAsReadMutation(baseOptions?: Apollo.MutationHookOptions<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>): Apollo.MutationTuple<MarkActivityAsReadMutation, Exact<{
    id?: string | null | undefined;
    read?: boolean | null | undefined;
}>>;
export declare type MarkActivityAsReadMutationHookResult = ReturnType<typeof useMarkActivityAsReadMutation>;
export declare type MarkActivityAsReadMutationResult = Apollo.MutationResult<MarkActivityAsReadMutation>;
export declare type MarkActivityAsReadMutationOptions = Apollo.BaseMutationOptions<MarkActivityAsReadMutation, MarkActivityAsReadMutationVariables>;
export declare const GraphQlMarkAllActivitiesAsReadDocument: Apollo.DocumentNode;
export declare type GraphQlMarkAllActivitiesAsReadMutationFn = Apollo.MutationFunction<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>;
/**
 * __useGraphQlMarkAllActivitiesAsReadMutation__
 *
 * To run a mutation, you first call `useGraphQlMarkAllActivitiesAsReadMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlMarkAllActivitiesAsReadMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlMarkAllActivitiesAsReadMutation, { data, loading, error }] = useGraphQlMarkAllActivitiesAsReadMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlMarkAllActivitiesAsReadMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>): Apollo.MutationTuple<GraphQlMarkAllActivitiesAsReadMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlMarkAllActivitiesAsReadMutationHookResult = ReturnType<typeof useGraphQlMarkAllActivitiesAsReadMutation>;
export declare type GraphQlMarkAllActivitiesAsReadMutationResult = Apollo.MutationResult<GraphQlMarkAllActivitiesAsReadMutation>;
export declare type GraphQlMarkAllActivitiesAsReadMutationOptions = Apollo.BaseMutationOptions<GraphQlMarkAllActivitiesAsReadMutation, GraphQlMarkAllActivitiesAsReadMutationVariables>;
export declare const AutocompleteCitiesDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteCitiesQuery__
 *
 * To run a query within a React component, call `useAutocompleteCitiesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteCitiesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteCitiesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useAutocompleteCitiesQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteCitiesQuery, AutocompleteCitiesQueryVariables>): Apollo.QueryResult<AutocompleteCitiesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useAutocompleteCitiesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteCitiesQuery, AutocompleteCitiesQueryVariables>): Apollo.QueryTuple<AutocompleteCitiesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type AutocompleteCitiesQueryHookResult = ReturnType<typeof useAutocompleteCitiesQuery>;
export declare type AutocompleteCitiesLazyQueryHookResult = ReturnType<typeof useAutocompleteCitiesLazyQuery>;
export declare type AutocompleteCitiesQueryResult = Apollo.QueryResult<AutocompleteCitiesQuery, AutocompleteCitiesQueryVariables>;
export declare const CreateCommentDocument: Apollo.DocumentNode;
export declare type CreateCommentMutationFn = Apollo.MutationFunction<CreateCommentMutation, CreateCommentMutationVariables>;
/**
 * __useCreateCommentMutation__
 *
 * To run a mutation, you first call `useCreateCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentMutation, { data, loading, error }] = useCreateCommentMutation({
 *   variables: {
 *      user: // value for 'user'
 *      text: // value for 'text'
 *      attachment: // value for 'attachment'
 *      course: // value for 'course'
 *      resource: // value for 'resource'
 *      comment: // value for 'comment'
 *      school: // value for 'school'
 *   },
 * });
 */
export declare function useCreateCommentMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentMutation, CreateCommentMutationVariables>): Apollo.MutationTuple<CreateCommentMutation, Exact<{
    user?: string | null | undefined;
    text: string;
    attachment?: string | null | undefined;
    course?: string | null | undefined;
    resource?: string | null | undefined;
    comment?: string | null | undefined;
    school?: string | null | undefined;
}>>;
export declare type CreateCommentMutationHookResult = ReturnType<typeof useCreateCommentMutation>;
export declare type CreateCommentMutationResult = Apollo.MutationResult<CreateCommentMutation>;
export declare type CreateCommentMutationOptions = Apollo.BaseMutationOptions<CreateCommentMutation, CreateCommentMutationVariables>;
export declare const DeleteCommentDocument: Apollo.DocumentNode;
export declare type DeleteCommentMutationFn = Apollo.MutationFunction<DeleteCommentMutation, DeleteCommentMutationVariables>;
/**
 * __useDeleteCommentMutation__
 *
 * To run a mutation, you first call `useDeleteCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCommentMutation, { data, loading, error }] = useDeleteCommentMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useDeleteCommentMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCommentMutation, DeleteCommentMutationVariables>): Apollo.MutationTuple<DeleteCommentMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type DeleteCommentMutationHookResult = ReturnType<typeof useDeleteCommentMutation>;
export declare type DeleteCommentMutationResult = Apollo.MutationResult<DeleteCommentMutation>;
export declare type DeleteCommentMutationOptions = Apollo.BaseMutationOptions<DeleteCommentMutation, DeleteCommentMutationVariables>;
export declare const CreateContactMessageDocument: Apollo.DocumentNode;
export declare type CreateContactMessageMutationFn = Apollo.MutationFunction<CreateContactMessageMutation, CreateContactMessageMutationVariables>;
/**
 * __useCreateContactMessageMutation__
 *
 * To run a mutation, you first call `useCreateContactMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateContactMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createContactMessageMutation, { data, loading, error }] = useCreateContactMessageMutation({
 *   variables: {
 *      subject: // value for 'subject'
 *      name: // value for 'name'
 *      email: // value for 'email'
 *      message: // value for 'message'
 *   },
 * });
 */
export declare function useCreateContactMessageMutation(baseOptions?: Apollo.MutationHookOptions<CreateContactMessageMutation, CreateContactMessageMutationVariables>): Apollo.MutationTuple<CreateContactMessageMutation, Exact<{
    subject: string;
    name?: string | null | undefined;
    email: string;
    message: string;
}>>;
export declare type CreateContactMessageMutationHookResult = ReturnType<typeof useCreateContactMessageMutation>;
export declare type CreateContactMessageMutationResult = Apollo.MutationResult<CreateContactMessageMutation>;
export declare type CreateContactMessageMutationOptions = Apollo.BaseMutationOptions<CreateContactMessageMutation, CreateContactMessageMutationVariables>;
export declare const AutocompleteCountriesDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteCountriesQuery__
 *
 * To run a query within a React component, call `useAutocompleteCountriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteCountriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteCountriesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useAutocompleteCountriesQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteCountriesQuery, AutocompleteCountriesQueryVariables>): Apollo.QueryResult<AutocompleteCountriesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useAutocompleteCountriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteCountriesQuery, AutocompleteCountriesQueryVariables>): Apollo.QueryTuple<AutocompleteCountriesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type AutocompleteCountriesQueryHookResult = ReturnType<typeof useAutocompleteCountriesQuery>;
export declare type AutocompleteCountriesLazyQueryHookResult = ReturnType<typeof useAutocompleteCountriesLazyQuery>;
export declare type AutocompleteCountriesQueryResult = Apollo.QueryResult<AutocompleteCountriesQuery, AutocompleteCountriesQueryVariables>;
export declare const CoursesDocument: Apollo.DocumentNode;
/**
 * __useCoursesQuery__
 *
 * To run a query within a React component, call `useCoursesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCoursesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCoursesQuery({
 *   variables: {
 *      searchTerm: // value for 'searchTerm'
 *      school: // value for 'school'
 *      subject: // value for 'subject'
 *      schoolType: // value for 'schoolType'
 *      country: // value for 'country'
 *      city: // value for 'city'
 *      ordering: // value for 'ordering'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useCoursesQuery(baseOptions?: Apollo.QueryHookOptions<CoursesQuery, CoursesQueryVariables>): Apollo.QueryResult<CoursesQuery, Exact<{
    searchTerm?: string | null | undefined;
    school?: string | null | undefined;
    subject?: string | null | undefined;
    schoolType?: string | null | undefined;
    country?: string | null | undefined;
    city?: string | null | undefined;
    ordering?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useCoursesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CoursesQuery, CoursesQueryVariables>): Apollo.QueryTuple<CoursesQuery, Exact<{
    searchTerm?: string | null | undefined;
    school?: string | null | undefined;
    subject?: string | null | undefined;
    schoolType?: string | null | undefined;
    country?: string | null | undefined;
    city?: string | null | undefined;
    ordering?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type CoursesQueryHookResult = ReturnType<typeof useCoursesQuery>;
export declare type CoursesLazyQueryHookResult = ReturnType<typeof useCoursesLazyQuery>;
export declare type CoursesQueryResult = Apollo.QueryResult<CoursesQuery, CoursesQueryVariables>;
export declare const CourseDocument: Apollo.DocumentNode;
/**
 * __useCourseQuery__
 *
 * To run a query within a React component, call `useCourseQuery` and pass it any options that fit your needs.
 * When your component renders, `useCourseQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCourseQuery({
 *   variables: {
 *      id: // value for 'id'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useCourseQuery(baseOptions?: Apollo.QueryHookOptions<CourseQuery, CourseQueryVariables>): Apollo.QueryResult<CourseQuery, Exact<{
    id?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useCourseLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CourseQuery, CourseQueryVariables>): Apollo.QueryTuple<CourseQuery, Exact<{
    id?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type CourseQueryHookResult = ReturnType<typeof useCourseQuery>;
export declare type CourseLazyQueryHookResult = ReturnType<typeof useCourseLazyQuery>;
export declare type CourseQueryResult = Apollo.QueryResult<CourseQuery, CourseQueryVariables>;
export declare const CourseSeoPropsDocument: Apollo.DocumentNode;
/**
 * __useCourseSeoPropsQuery__
 *
 * To run a query within a React component, call `useCourseSeoPropsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCourseSeoPropsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCourseSeoPropsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useCourseSeoPropsQuery(baseOptions?: Apollo.QueryHookOptions<CourseSeoPropsQuery, CourseSeoPropsQueryVariables>): Apollo.QueryResult<CourseSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare function useCourseSeoPropsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CourseSeoPropsQuery, CourseSeoPropsQueryVariables>): Apollo.QueryTuple<CourseSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare type CourseSeoPropsQueryHookResult = ReturnType<typeof useCourseSeoPropsQuery>;
export declare type CourseSeoPropsLazyQueryHookResult = ReturnType<typeof useCourseSeoPropsLazyQuery>;
export declare type CourseSeoPropsQueryResult = Apollo.QueryResult<CourseSeoPropsQuery, CourseSeoPropsQueryVariables>;
export declare const CreateCourseAutocompleteDataDocument: Apollo.DocumentNode;
/**
 * __useCreateCourseAutocompleteDataQuery__
 *
 * To run a query within a React component, call `useCreateCourseAutocompleteDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateCourseAutocompleteDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateCourseAutocompleteDataQuery({
 *   variables: {
 *      school: // value for 'school'
 *   },
 * });
 */
export declare function useCreateCourseAutocompleteDataQuery(baseOptions?: Apollo.QueryHookOptions<CreateCourseAutocompleteDataQuery, CreateCourseAutocompleteDataQueryVariables>): Apollo.QueryResult<CreateCourseAutocompleteDataQuery, Exact<{
    school?: string | null | undefined;
}>>;
export declare function useCreateCourseAutocompleteDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateCourseAutocompleteDataQuery, CreateCourseAutocompleteDataQueryVariables>): Apollo.QueryTuple<CreateCourseAutocompleteDataQuery, Exact<{
    school?: string | null | undefined;
}>>;
export declare type CreateCourseAutocompleteDataQueryHookResult = ReturnType<typeof useCreateCourseAutocompleteDataQuery>;
export declare type CreateCourseAutocompleteDataLazyQueryHookResult = ReturnType<typeof useCreateCourseAutocompleteDataLazyQuery>;
export declare type CreateCourseAutocompleteDataQueryResult = Apollo.QueryResult<CreateCourseAutocompleteDataQuery, CreateCourseAutocompleteDataQueryVariables>;
export declare const AutocompleteCoursesDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteCoursesQuery__
 *
 * To run a query within a React component, call `useAutocompleteCoursesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteCoursesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteCoursesQuery({
 *   variables: {
 *      school: // value for 'school'
 *      name: // value for 'name'
 *   },
 * });
 */
export declare function useAutocompleteCoursesQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteCoursesQuery, AutocompleteCoursesQueryVariables>): Apollo.QueryResult<AutocompleteCoursesQuery, Exact<{
    school?: string | null | undefined;
    name?: string | null | undefined;
}>>;
export declare function useAutocompleteCoursesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteCoursesQuery, AutocompleteCoursesQueryVariables>): Apollo.QueryTuple<AutocompleteCoursesQuery, Exact<{
    school?: string | null | undefined;
    name?: string | null | undefined;
}>>;
export declare type AutocompleteCoursesQueryHookResult = ReturnType<typeof useAutocompleteCoursesQuery>;
export declare type AutocompleteCoursesLazyQueryHookResult = ReturnType<typeof useAutocompleteCoursesLazyQuery>;
export declare type AutocompleteCoursesQueryResult = Apollo.QueryResult<AutocompleteCoursesQuery, AutocompleteCoursesQueryVariables>;
export declare const CreateCourseDocument: Apollo.DocumentNode;
export declare type CreateCourseMutationFn = Apollo.MutationFunction<CreateCourseMutation, CreateCourseMutationVariables>;
/**
 * __useCreateCourseMutation__
 *
 * To run a mutation, you first call `useCreateCourseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCourseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCourseMutation, { data, loading, error }] = useCreateCourseMutation({
 *   variables: {
 *      courseName: // value for 'courseName'
 *      courseCode: // value for 'courseCode'
 *      subjects: // value for 'subjects'
 *      school: // value for 'school'
 *   },
 * });
 */
export declare function useCreateCourseMutation(baseOptions?: Apollo.MutationHookOptions<CreateCourseMutation, CreateCourseMutationVariables>): Apollo.MutationTuple<CreateCourseMutation, Exact<{
    courseName: string;
    courseCode?: string | null | undefined;
    subjects?: string | Maybe<string>[] | null | undefined;
    school: string;
}>>;
export declare type CreateCourseMutationHookResult = ReturnType<typeof useCreateCourseMutation>;
export declare type CreateCourseMutationResult = Apollo.MutationResult<CreateCourseMutation>;
export declare type CreateCourseMutationOptions = Apollo.BaseMutationOptions<CreateCourseMutation, CreateCourseMutationVariables>;
export declare const DeleteCourseDocument: Apollo.DocumentNode;
export declare type DeleteCourseMutationFn = Apollo.MutationFunction<DeleteCourseMutation, DeleteCourseMutationVariables>;
/**
 * __useDeleteCourseMutation__
 *
 * To run a mutation, you first call `useDeleteCourseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCourseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCourseMutation, { data, loading, error }] = useDeleteCourseMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useDeleteCourseMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCourseMutation, DeleteCourseMutationVariables>): Apollo.MutationTuple<DeleteCourseMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type DeleteCourseMutationHookResult = ReturnType<typeof useDeleteCourseMutation>;
export declare type DeleteCourseMutationResult = Apollo.MutationResult<DeleteCourseMutation>;
export declare type DeleteCourseMutationOptions = Apollo.BaseMutationOptions<DeleteCourseMutation, DeleteCourseMutationVariables>;
export declare const ResourceDocument: Apollo.DocumentNode;
/**
 * __useResourceQuery__
 *
 * To run a query within a React component, call `useResourceQuery` and pass it any options that fit your needs.
 * When your component renders, `useResourceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResourceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useResourceQuery(baseOptions?: Apollo.QueryHookOptions<ResourceQuery, ResourceQueryVariables>): Apollo.QueryResult<ResourceQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare function useResourceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResourceQuery, ResourceQueryVariables>): Apollo.QueryTuple<ResourceQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare type ResourceQueryHookResult = ReturnType<typeof useResourceQuery>;
export declare type ResourceLazyQueryHookResult = ReturnType<typeof useResourceLazyQuery>;
export declare type ResourceQueryResult = Apollo.QueryResult<ResourceQuery, ResourceQueryVariables>;
export declare const ResourceSeoPropsDocument: Apollo.DocumentNode;
/**
 * __useResourceSeoPropsQuery__
 *
 * To run a query within a React component, call `useResourceSeoPropsQuery` and pass it any options that fit your needs.
 * When your component renders, `useResourceSeoPropsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useResourceSeoPropsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useResourceSeoPropsQuery(baseOptions?: Apollo.QueryHookOptions<ResourceSeoPropsQuery, ResourceSeoPropsQueryVariables>): Apollo.QueryResult<ResourceSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare function useResourceSeoPropsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ResourceSeoPropsQuery, ResourceSeoPropsQueryVariables>): Apollo.QueryTuple<ResourceSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare type ResourceSeoPropsQueryHookResult = ReturnType<typeof useResourceSeoPropsQuery>;
export declare type ResourceSeoPropsLazyQueryHookResult = ReturnType<typeof useResourceSeoPropsLazyQuery>;
export declare type ResourceSeoPropsQueryResult = Apollo.QueryResult<ResourceSeoPropsQuery, ResourceSeoPropsQueryVariables>;
export declare const CreateResourceAutocompleteDataDocument: Apollo.DocumentNode;
/**
 * __useCreateResourceAutocompleteDataQuery__
 *
 * To run a query within a React component, call `useCreateResourceAutocompleteDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateResourceAutocompleteDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateResourceAutocompleteDataQuery({
 *   variables: {
 *      school: // value for 'school'
 *      course: // value for 'course'
 *   },
 * });
 */
export declare function useCreateResourceAutocompleteDataQuery(baseOptions?: Apollo.QueryHookOptions<CreateResourceAutocompleteDataQuery, CreateResourceAutocompleteDataQueryVariables>): Apollo.QueryResult<CreateResourceAutocompleteDataQuery, Exact<{
    school?: string | null | undefined;
    course?: string | null | undefined;
}>>;
export declare function useCreateResourceAutocompleteDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateResourceAutocompleteDataQuery, CreateResourceAutocompleteDataQueryVariables>): Apollo.QueryTuple<CreateResourceAutocompleteDataQuery, Exact<{
    school?: string | null | undefined;
    course?: string | null | undefined;
}>>;
export declare type CreateResourceAutocompleteDataQueryHookResult = ReturnType<typeof useCreateResourceAutocompleteDataQuery>;
export declare type CreateResourceAutocompleteDataLazyQueryHookResult = ReturnType<typeof useCreateResourceAutocompleteDataLazyQuery>;
export declare type CreateResourceAutocompleteDataQueryResult = Apollo.QueryResult<CreateResourceAutocompleteDataQuery, CreateResourceAutocompleteDataQueryVariables>;
export declare const AutocompleteResourceTypesDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteResourceTypesQuery__
 *
 * To run a query within a React component, call `useAutocompleteResourceTypesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteResourceTypesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteResourceTypesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useAutocompleteResourceTypesQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteResourceTypesQuery, AutocompleteResourceTypesQueryVariables>): Apollo.QueryResult<AutocompleteResourceTypesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useAutocompleteResourceTypesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteResourceTypesQuery, AutocompleteResourceTypesQueryVariables>): Apollo.QueryTuple<AutocompleteResourceTypesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type AutocompleteResourceTypesQueryHookResult = ReturnType<typeof useAutocompleteResourceTypesQuery>;
export declare type AutocompleteResourceTypesLazyQueryHookResult = ReturnType<typeof useAutocompleteResourceTypesLazyQuery>;
export declare type AutocompleteResourceTypesQueryResult = Apollo.QueryResult<AutocompleteResourceTypesQuery, AutocompleteResourceTypesQueryVariables>;
export declare const CreateResourceDocument: Apollo.DocumentNode;
export declare type CreateResourceMutationFn = Apollo.MutationFunction<CreateResourceMutation, CreateResourceMutationVariables>;
/**
 * __useCreateResourceMutation__
 *
 * To run a mutation, you first call `useCreateResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createResourceMutation, { data, loading, error }] = useCreateResourceMutation({
 *   variables: {
 *      resourceTitle: // value for 'resourceTitle'
 *      resourceType: // value for 'resourceType'
 *      date: // value for 'date'
 *      course: // value for 'course'
 *      file: // value for 'file'
 *   },
 * });
 */
export declare function useCreateResourceMutation(baseOptions?: Apollo.MutationHookOptions<CreateResourceMutation, CreateResourceMutationVariables>): Apollo.MutationTuple<CreateResourceMutation, Exact<{
    resourceTitle: string;
    resourceType: string;
    date?: any;
    course: string;
    file: string;
}>>;
export declare type CreateResourceMutationHookResult = ReturnType<typeof useCreateResourceMutation>;
export declare type CreateResourceMutationResult = Apollo.MutationResult<CreateResourceMutation>;
export declare type CreateResourceMutationOptions = Apollo.BaseMutationOptions<CreateResourceMutation, CreateResourceMutationVariables>;
export declare const DeleteResourceDocument: Apollo.DocumentNode;
export declare type DeleteResourceMutationFn = Apollo.MutationFunction<DeleteResourceMutation, DeleteResourceMutationVariables>;
/**
 * __useDeleteResourceMutation__
 *
 * To run a mutation, you first call `useDeleteResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteResourceMutation, { data, loading, error }] = useDeleteResourceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useDeleteResourceMutation(baseOptions?: Apollo.MutationHookOptions<DeleteResourceMutation, DeleteResourceMutationVariables>): Apollo.MutationTuple<DeleteResourceMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type DeleteResourceMutationHookResult = ReturnType<typeof useDeleteResourceMutation>;
export declare type DeleteResourceMutationResult = Apollo.MutationResult<DeleteResourceMutation>;
export declare type DeleteResourceMutationOptions = Apollo.BaseMutationOptions<DeleteResourceMutation, DeleteResourceMutationVariables>;
export declare const DownloadResourceDocument: Apollo.DocumentNode;
export declare type DownloadResourceMutationFn = Apollo.MutationFunction<DownloadResourceMutation, DownloadResourceMutationVariables>;
/**
 * __useDownloadResourceMutation__
 *
 * To run a mutation, you first call `useDownloadResourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDownloadResourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [downloadResourceMutation, { data, loading, error }] = useDownloadResourceMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useDownloadResourceMutation(baseOptions?: Apollo.MutationHookOptions<DownloadResourceMutation, DownloadResourceMutationVariables>): Apollo.MutationTuple<DownloadResourceMutation, Exact<{
    id?: string | null | undefined;
}>>;
export declare type DownloadResourceMutationHookResult = ReturnType<typeof useDownloadResourceMutation>;
export declare type DownloadResourceMutationResult = Apollo.MutationResult<DownloadResourceMutation>;
export declare type DownloadResourceMutationOptions = Apollo.BaseMutationOptions<DownloadResourceMutation, DownloadResourceMutationVariables>;
export declare const SchoolDocument: Apollo.DocumentNode;
/**
 * __useSchoolQuery__
 *
 * To run a query within a React component, call `useSchoolQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchoolQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchoolQuery({
 *   variables: {
 *      id: // value for 'id'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useSchoolQuery(baseOptions?: Apollo.QueryHookOptions<SchoolQuery, SchoolQueryVariables>): Apollo.QueryResult<SchoolQuery, Exact<{
    id?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useSchoolLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchoolQuery, SchoolQueryVariables>): Apollo.QueryTuple<SchoolQuery, Exact<{
    id?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type SchoolQueryHookResult = ReturnType<typeof useSchoolQuery>;
export declare type SchoolLazyQueryHookResult = ReturnType<typeof useSchoolLazyQuery>;
export declare type SchoolQueryResult = Apollo.QueryResult<SchoolQuery, SchoolQueryVariables>;
export declare const SchoolSeoPropsDocument: Apollo.DocumentNode;
/**
 * __useSchoolSeoPropsQuery__
 *
 * To run a query within a React component, call `useSchoolSeoPropsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchoolSeoPropsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchoolSeoPropsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useSchoolSeoPropsQuery(baseOptions?: Apollo.QueryHookOptions<SchoolSeoPropsQuery, SchoolSeoPropsQueryVariables>): Apollo.QueryResult<SchoolSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare function useSchoolSeoPropsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SchoolSeoPropsQuery, SchoolSeoPropsQueryVariables>): Apollo.QueryTuple<SchoolSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare type SchoolSeoPropsQueryHookResult = ReturnType<typeof useSchoolSeoPropsQuery>;
export declare type SchoolSeoPropsLazyQueryHookResult = ReturnType<typeof useSchoolSeoPropsLazyQuery>;
export declare type SchoolSeoPropsQueryResult = Apollo.QueryResult<SchoolSeoPropsQuery, SchoolSeoPropsQueryVariables>;
export declare const AutocompleteSchoolsDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteSchoolsQuery__
 *
 * To run a query within a React component, call `useAutocompleteSchoolsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteSchoolsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteSchoolsQuery({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export declare function useAutocompleteSchoolsQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteSchoolsQuery, AutocompleteSchoolsQueryVariables>): Apollo.QueryResult<AutocompleteSchoolsQuery, Exact<{
    name?: string | null | undefined;
}>>;
export declare function useAutocompleteSchoolsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteSchoolsQuery, AutocompleteSchoolsQueryVariables>): Apollo.QueryTuple<AutocompleteSchoolsQuery, Exact<{
    name?: string | null | undefined;
}>>;
export declare type AutocompleteSchoolsQueryHookResult = ReturnType<typeof useAutocompleteSchoolsQuery>;
export declare type AutocompleteSchoolsLazyQueryHookResult = ReturnType<typeof useAutocompleteSchoolsLazyQuery>;
export declare type AutocompleteSchoolsQueryResult = Apollo.QueryResult<AutocompleteSchoolsQuery, AutocompleteSchoolsQueryVariables>;
export declare const AutocompleteSchoolTypesDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteSchoolTypesQuery__
 *
 * To run a query within a React component, call `useAutocompleteSchoolTypesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteSchoolTypesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteSchoolTypesQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useAutocompleteSchoolTypesQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteSchoolTypesQuery, AutocompleteSchoolTypesQueryVariables>): Apollo.QueryResult<AutocompleteSchoolTypesQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useAutocompleteSchoolTypesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteSchoolTypesQuery, AutocompleteSchoolTypesQueryVariables>): Apollo.QueryTuple<AutocompleteSchoolTypesQuery, Exact<{
    [key: string]: never;
}>>;
export declare type AutocompleteSchoolTypesQueryHookResult = ReturnType<typeof useAutocompleteSchoolTypesQuery>;
export declare type AutocompleteSchoolTypesLazyQueryHookResult = ReturnType<typeof useAutocompleteSchoolTypesLazyQuery>;
export declare type AutocompleteSchoolTypesQueryResult = Apollo.QueryResult<AutocompleteSchoolTypesQuery, AutocompleteSchoolTypesQueryVariables>;
export declare const StarredDocument: Apollo.DocumentNode;
/**
 * __useStarredQuery__
 *
 * To run a query within a React component, call `useStarredQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarredQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarredQuery({
 *   variables: {
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useStarredQuery(baseOptions?: Apollo.QueryHookOptions<StarredQuery, StarredQueryVariables>): Apollo.QueryResult<StarredQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useStarredLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarredQuery, StarredQueryVariables>): Apollo.QueryTuple<StarredQuery, Exact<{
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type StarredQueryHookResult = ReturnType<typeof useStarredQuery>;
export declare type StarredLazyQueryHookResult = ReturnType<typeof useStarredLazyQuery>;
export declare type StarredQueryResult = Apollo.QueryResult<StarredQuery, StarredQueryVariables>;
export declare const StarDocument: Apollo.DocumentNode;
export declare type StarMutationFn = Apollo.MutationFunction<StarMutation, StarMutationVariables>;
/**
 * __useStarMutation__
 *
 * To run a mutation, you first call `useStarMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStarMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [starMutation, { data, loading, error }] = useStarMutation({
 *   variables: {
 *      course: // value for 'course'
 *      resource: // value for 'resource'
 *   },
 * });
 */
export declare function useStarMutation(baseOptions?: Apollo.MutationHookOptions<StarMutation, StarMutationVariables>): Apollo.MutationTuple<StarMutation, Exact<{
    course?: string | null | undefined;
    resource?: string | null | undefined;
}>>;
export declare type StarMutationHookResult = ReturnType<typeof useStarMutation>;
export declare type StarMutationResult = Apollo.MutationResult<StarMutation>;
export declare type StarMutationOptions = Apollo.BaseMutationOptions<StarMutation, StarMutationVariables>;
export declare const AutocompleteSubjectsDocument: Apollo.DocumentNode;
/**
 * __useAutocompleteSubjectsQuery__
 *
 * To run a query within a React component, call `useAutocompleteSubjectsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAutocompleteSubjectsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAutocompleteSubjectsQuery({
 *   variables: {
 *      name: // value for 'name'
 *   },
 * });
 */
export declare function useAutocompleteSubjectsQuery(baseOptions?: Apollo.QueryHookOptions<AutocompleteSubjectsQuery, AutocompleteSubjectsQueryVariables>): Apollo.QueryResult<AutocompleteSubjectsQuery, Exact<{
    name?: string | null | undefined;
}>>;
export declare function useAutocompleteSubjectsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AutocompleteSubjectsQuery, AutocompleteSubjectsQueryVariables>): Apollo.QueryTuple<AutocompleteSubjectsQuery, Exact<{
    name?: string | null | undefined;
}>>;
export declare type AutocompleteSubjectsQueryHookResult = ReturnType<typeof useAutocompleteSubjectsQuery>;
export declare type AutocompleteSubjectsLazyQueryHookResult = ReturnType<typeof useAutocompleteSubjectsLazyQuery>;
export declare type AutocompleteSubjectsQueryResult = Apollo.QueryResult<AutocompleteSubjectsQuery, AutocompleteSubjectsQueryVariables>;
export declare const UserMeDocument: Apollo.DocumentNode;
/**
 * __useUserMeQuery__
 *
 * To run a query within a React component, call `useUserMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserMeQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useUserMeQuery(baseOptions?: Apollo.QueryHookOptions<UserMeQuery, UserMeQueryVariables>): Apollo.QueryResult<UserMeQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useUserMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserMeQuery, UserMeQueryVariables>): Apollo.QueryTuple<UserMeQuery, Exact<{
    [key: string]: never;
}>>;
export declare type UserMeQueryHookResult = ReturnType<typeof useUserMeQuery>;
export declare type UserMeLazyQueryHookResult = ReturnType<typeof useUserMeLazyQuery>;
export declare type UserMeQueryResult = Apollo.QueryResult<UserMeQuery, UserMeQueryVariables>;
export declare const UserDocument: Apollo.DocumentNode;
/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *      page: // value for 'page'
 *      pageSize: // value for 'pageSize'
 *   },
 * });
 */
export declare function useUserQuery(baseOptions?: Apollo.QueryHookOptions<UserQuery, UserQueryVariables>): Apollo.QueryResult<UserQuery, Exact<{
    id?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>): Apollo.QueryTuple<UserQuery, Exact<{
    id?: string | null | undefined;
    page?: number | null | undefined;
    pageSize?: number | null | undefined;
}>>;
export declare type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export declare type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export declare type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export declare const UserSeoPropsDocument: Apollo.DocumentNode;
/**
 * __useUserSeoPropsQuery__
 *
 * To run a query within a React component, call `useUserSeoPropsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserSeoPropsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserSeoPropsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export declare function useUserSeoPropsQuery(baseOptions?: Apollo.QueryHookOptions<UserSeoPropsQuery, UserSeoPropsQueryVariables>): Apollo.QueryResult<UserSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare function useUserSeoPropsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserSeoPropsQuery, UserSeoPropsQueryVariables>): Apollo.QueryTuple<UserSeoPropsQuery, Exact<{
    id?: string | null | undefined;
}>>;
export declare type UserSeoPropsQueryHookResult = ReturnType<typeof useUserSeoPropsQuery>;
export declare type UserSeoPropsLazyQueryHookResult = ReturnType<typeof useUserSeoPropsLazyQuery>;
export declare type UserSeoPropsQueryResult = Apollo.QueryResult<UserSeoPropsQuery, UserSeoPropsQueryVariables>;
export declare const RegisterDocument: Apollo.DocumentNode;
export declare type RegisterMutationFn = Apollo.MutationFunction<RegisterMutation, RegisterMutationVariables>;
/**
 * __useRegisterMutation__
 *
 * To run a mutation, you first call `useRegisterMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegisterMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registerMutation, { data, loading, error }] = useRegisterMutation({
 *   variables: {
 *      username: // value for 'username'
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useRegisterMutation(baseOptions?: Apollo.MutationHookOptions<RegisterMutation, RegisterMutationVariables>): Apollo.MutationTuple<RegisterMutation, Exact<{
    username: string;
    email: string;
    password: string;
}>>;
export declare type RegisterMutationHookResult = ReturnType<typeof useRegisterMutation>;
export declare type RegisterMutationResult = Apollo.MutationResult<RegisterMutation>;
export declare type RegisterMutationOptions = Apollo.BaseMutationOptions<RegisterMutation, RegisterMutationVariables>;
export declare const LoginDocument: Apollo.DocumentNode;
export declare type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;
/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      usernameOrEmail: // value for 'usernameOrEmail'
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>): Apollo.MutationTuple<LoginMutation, Exact<{
    usernameOrEmail: string;
    password: string;
}>>;
export declare type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export declare type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export declare type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export declare const GraphQlLogoutDocument: Apollo.DocumentNode;
export declare type GraphQlLogoutMutationFn = Apollo.MutationFunction<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>;
/**
 * __useGraphQlLogoutMutation__
 *
 * To run a mutation, you first call `useGraphQlLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlLogoutMutation, { data, loading, error }] = useGraphQlLogoutMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlLogoutMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>): Apollo.MutationTuple<GraphQlLogoutMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlLogoutMutationHookResult = ReturnType<typeof useGraphQlLogoutMutation>;
export declare type GraphQlLogoutMutationResult = Apollo.MutationResult<GraphQlLogoutMutation>;
export declare type GraphQlLogoutMutationOptions = Apollo.BaseMutationOptions<GraphQlLogoutMutation, GraphQlLogoutMutationVariables>;
export declare const GraphQlResendVerificationEmailDocument: Apollo.DocumentNode;
export declare type GraphQlResendVerificationEmailMutationFn = Apollo.MutationFunction<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>;
/**
 * __useGraphQlResendVerificationEmailMutation__
 *
 * To run a mutation, you first call `useGraphQlResendVerificationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlResendVerificationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlResendVerificationEmailMutation, { data, loading, error }] = useGraphQlResendVerificationEmailMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlResendVerificationEmailMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>): Apollo.MutationTuple<GraphQlResendVerificationEmailMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlResendVerificationEmailMutationHookResult = ReturnType<typeof useGraphQlResendVerificationEmailMutation>;
export declare type GraphQlResendVerificationEmailMutationResult = Apollo.MutationResult<GraphQlResendVerificationEmailMutation>;
export declare type GraphQlResendVerificationEmailMutationOptions = Apollo.BaseMutationOptions<GraphQlResendVerificationEmailMutation, GraphQlResendVerificationEmailMutationVariables>;
export declare const GraphQlMyDataDocument: Apollo.DocumentNode;
export declare type GraphQlMyDataMutationFn = Apollo.MutationFunction<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>;
/**
 * __useGraphQlMyDataMutation__
 *
 * To run a mutation, you first call `useGraphQlMyDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGraphQlMyDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [graphQlMyDataMutation, { data, loading, error }] = useGraphQlMyDataMutation({
 *   variables: {
 *   },
 * });
 */
export declare function useGraphQlMyDataMutation(baseOptions?: Apollo.MutationHookOptions<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>): Apollo.MutationTuple<GraphQlMyDataMutation, Exact<{
    [key: string]: never;
}>>;
export declare type GraphQlMyDataMutationHookResult = ReturnType<typeof useGraphQlMyDataMutation>;
export declare type GraphQlMyDataMutationResult = Apollo.MutationResult<GraphQlMyDataMutation>;
export declare type GraphQlMyDataMutationOptions = Apollo.BaseMutationOptions<GraphQlMyDataMutation, GraphQlMyDataMutationVariables>;
export declare const VerifyAccountDocument: Apollo.DocumentNode;
export declare type VerifyAccountMutationFn = Apollo.MutationFunction<VerifyAccountMutation, VerifyAccountMutationVariables>;
/**
 * __useVerifyAccountMutation__
 *
 * To run a mutation, you first call `useVerifyAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyAccountMutation, { data, loading, error }] = useVerifyAccountMutation({
 *   variables: {
 *      token: // value for 'token'
 *   },
 * });
 */
export declare function useVerifyAccountMutation(baseOptions?: Apollo.MutationHookOptions<VerifyAccountMutation, VerifyAccountMutationVariables>): Apollo.MutationTuple<VerifyAccountMutation, Exact<{
    token?: string | null | undefined;
}>>;
export declare type VerifyAccountMutationHookResult = ReturnType<typeof useVerifyAccountMutation>;
export declare type VerifyAccountMutationResult = Apollo.MutationResult<VerifyAccountMutation>;
export declare type VerifyAccountMutationOptions = Apollo.BaseMutationOptions<VerifyAccountMutation, VerifyAccountMutationVariables>;
export declare const SendPasswordResetEmailDocument: Apollo.DocumentNode;
export declare type SendPasswordResetEmailMutationFn = Apollo.MutationFunction<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>;
/**
 * __useSendPasswordResetEmailMutation__
 *
 * To run a mutation, you first call `useSendPasswordResetEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendPasswordResetEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendPasswordResetEmailMutation, { data, loading, error }] = useSendPasswordResetEmailMutation({
 *   variables: {
 *      email: // value for 'email'
 *   },
 * });
 */
export declare function useSendPasswordResetEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>): Apollo.MutationTuple<SendPasswordResetEmailMutation, Exact<{
    email: string;
}>>;
export declare type SendPasswordResetEmailMutationHookResult = ReturnType<typeof useSendPasswordResetEmailMutation>;
export declare type SendPasswordResetEmailMutationResult = Apollo.MutationResult<SendPasswordResetEmailMutation>;
export declare type SendPasswordResetEmailMutationOptions = Apollo.BaseMutationOptions<SendPasswordResetEmailMutation, SendPasswordResetEmailMutationVariables>;
export declare const ResetPasswordDocument: Apollo.DocumentNode;
export declare type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;
/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      token: // value for 'token'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export declare function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>): Apollo.MutationTuple<ResetPasswordMutation, Exact<{
    token?: string | null | undefined;
    newPassword: string;
}>>;
export declare type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export declare type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export declare type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export declare const UpdateUserDocument: Apollo.DocumentNode;
export declare type UpdateUserMutationFn = Apollo.MutationFunction<UpdateUserMutation, UpdateUserMutationVariables>;
/**
 * __useUpdateUserMutation__
 *
 * To run a mutation, you first call `useUpdateUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserMutation, { data, loading, error }] = useUpdateUserMutation({
 *   variables: {
 *      username: // value for 'username'
 *      email: // value for 'email'
 *      title: // value for 'title'
 *      bio: // value for 'bio'
 *      avatar: // value for 'avatar'
 *      school: // value for 'school'
 *      subject: // value for 'subject'
 *   },
 * });
 */
export declare function useUpdateUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserMutation, UpdateUserMutationVariables>): Apollo.MutationTuple<UpdateUserMutation, Exact<{
    username: string;
    email: string;
    title?: string | null | undefined;
    bio?: string | null | undefined;
    avatar?: string | null | undefined;
    school?: string | null | undefined;
    subject?: string | null | undefined;
}>>;
export declare type UpdateUserMutationHookResult = ReturnType<typeof useUpdateUserMutation>;
export declare type UpdateUserMutationResult = Apollo.MutationResult<UpdateUserMutation>;
export declare type UpdateUserMutationOptions = Apollo.BaseMutationOptions<UpdateUserMutation, UpdateUserMutationVariables>;
export declare const ChangePasswordDocument: Apollo.DocumentNode;
export declare type ChangePasswordMutationFn = Apollo.MutationFunction<ChangePasswordMutation, ChangePasswordMutationVariables>;
/**
 * __useChangePasswordMutation__
 *
 * To run a mutation, you first call `useChangePasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangePasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changePasswordMutation, { data, loading, error }] = useChangePasswordMutation({
 *   variables: {
 *      oldPassword: // value for 'oldPassword'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export declare function useChangePasswordMutation(baseOptions?: Apollo.MutationHookOptions<ChangePasswordMutation, ChangePasswordMutationVariables>): Apollo.MutationTuple<ChangePasswordMutation, Exact<{
    oldPassword: string;
    newPassword: string;
}>>;
export declare type ChangePasswordMutationHookResult = ReturnType<typeof useChangePasswordMutation>;
export declare type ChangePasswordMutationResult = Apollo.MutationResult<ChangePasswordMutation>;
export declare type ChangePasswordMutationOptions = Apollo.BaseMutationOptions<ChangePasswordMutation, ChangePasswordMutationVariables>;
export declare const DeleteUserDocument: Apollo.DocumentNode;
export declare type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;
/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      password: // value for 'password'
 *   },
 * });
 */
export declare function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>): Apollo.MutationTuple<DeleteUserMutation, Exact<{
    password: string;
}>>;
export declare type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export declare type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export declare type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export declare const VoteDocument: Apollo.DocumentNode;
export declare type VoteMutationFn = Apollo.MutationFunction<VoteMutation, VoteMutationVariables>;
/**
 * __useVoteMutation__
 *
 * To run a mutation, you first call `useVoteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVoteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [voteMutation, { data, loading, error }] = useVoteMutation({
 *   variables: {
 *      status: // value for 'status'
 *      comment: // value for 'comment'
 *      course: // value for 'course'
 *      resource: // value for 'resource'
 *   },
 * });
 */
export declare function useVoteMutation(baseOptions?: Apollo.MutationHookOptions<VoteMutation, VoteMutationVariables>): Apollo.MutationTuple<VoteMutation, Exact<{
    status: number;
    comment?: string | null | undefined;
    course?: string | null | undefined;
    resource?: string | null | undefined;
}>>;
export declare type VoteMutationHookResult = ReturnType<typeof useVoteMutation>;
export declare type VoteMutationResult = Apollo.MutationResult<VoteMutation>;
export declare type VoteMutationOptions = Apollo.BaseMutationOptions<VoteMutation, VoteMutationVariables>;
export declare const SitemapDocument: Apollo.DocumentNode;
/**
 * __useSitemapQuery__
 *
 * To run a query within a React component, call `useSitemapQuery` and pass it any options that fit your needs.
 * When your component renders, `useSitemapQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSitemapQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useSitemapQuery(baseOptions?: Apollo.QueryHookOptions<SitemapQuery, SitemapQueryVariables>): Apollo.QueryResult<SitemapQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useSitemapLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SitemapQuery, SitemapQueryVariables>): Apollo.QueryTuple<SitemapQuery, Exact<{
    [key: string]: never;
}>>;
export declare type SitemapQueryHookResult = ReturnType<typeof useSitemapQuery>;
export declare type SitemapLazyQueryHookResult = ReturnType<typeof useSitemapLazyQuery>;
export declare type SitemapQueryResult = Apollo.QueryResult<SitemapQuery, SitemapQueryVariables>;
export declare const SuggestionsDocument: Apollo.DocumentNode;
/**
 * __useSuggestionsQuery__
 *
 * To run a query within a React component, call `useSuggestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSuggestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSuggestionsQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useSuggestionsQuery(baseOptions?: Apollo.QueryHookOptions<SuggestionsQuery, SuggestionsQueryVariables>): Apollo.QueryResult<SuggestionsQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useSuggestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SuggestionsQuery, SuggestionsQueryVariables>): Apollo.QueryTuple<SuggestionsQuery, Exact<{
    [key: string]: never;
}>>;
export declare type SuggestionsQueryHookResult = ReturnType<typeof useSuggestionsQuery>;
export declare type SuggestionsLazyQueryHookResult = ReturnType<typeof useSuggestionsLazyQuery>;
export declare type SuggestionsQueryResult = Apollo.QueryResult<SuggestionsQuery, SuggestionsQueryVariables>;
export declare const SuggestionsPreviewDocument: Apollo.DocumentNode;
/**
 * __useSuggestionsPreviewQuery__
 *
 * To run a query within a React component, call `useSuggestionsPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useSuggestionsPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSuggestionsPreviewQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useSuggestionsPreviewQuery(baseOptions?: Apollo.QueryHookOptions<SuggestionsPreviewQuery, SuggestionsPreviewQueryVariables>): Apollo.QueryResult<SuggestionsPreviewQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useSuggestionsPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SuggestionsPreviewQuery, SuggestionsPreviewQueryVariables>): Apollo.QueryTuple<SuggestionsPreviewQuery, Exact<{
    [key: string]: never;
}>>;
export declare type SuggestionsPreviewQueryHookResult = ReturnType<typeof useSuggestionsPreviewQuery>;
export declare type SuggestionsPreviewLazyQueryHookResult = ReturnType<typeof useSuggestionsPreviewLazyQuery>;
export declare type SuggestionsPreviewQueryResult = Apollo.QueryResult<SuggestionsPreviewQuery, SuggestionsPreviewQueryVariables>;
export declare const DiscussionDocument: Apollo.DocumentNode;
/**
 * __useDiscussionQuery__
 *
 * To run a query within a React component, call `useDiscussionQuery` and pass it any options that fit your needs.
 * When your component renders, `useDiscussionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDiscussionQuery({
 *   variables: {
 *      course: // value for 'course'
 *      resource: // value for 'resource'
 *      school: // value for 'school'
 *   },
 * });
 */
export declare function useDiscussionQuery(baseOptions?: Apollo.QueryHookOptions<DiscussionQuery, DiscussionQueryVariables>): Apollo.QueryResult<DiscussionQuery, Exact<{
    course?: string | null | undefined;
    resource?: string | null | undefined;
    school?: string | null | undefined;
}>>;
export declare function useDiscussionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DiscussionQuery, DiscussionQueryVariables>): Apollo.QueryTuple<DiscussionQuery, Exact<{
    course?: string | null | undefined;
    resource?: string | null | undefined;
    school?: string | null | undefined;
}>>;
export declare type DiscussionQueryHookResult = ReturnType<typeof useDiscussionQuery>;
export declare type DiscussionLazyQueryHookResult = ReturnType<typeof useDiscussionLazyQuery>;
export declare type DiscussionQueryResult = Apollo.QueryResult<DiscussionQuery, DiscussionQueryVariables>;
export declare const DiscussionSuggestionsDocument: Apollo.DocumentNode;
/**
 * __useDiscussionSuggestionsQuery__
 *
 * To run a query within a React component, call `useDiscussionSuggestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useDiscussionSuggestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDiscussionSuggestionsQuery({
 *   variables: {
 *   },
 * });
 */
export declare function useDiscussionSuggestionsQuery(baseOptions?: Apollo.QueryHookOptions<DiscussionSuggestionsQuery, DiscussionSuggestionsQueryVariables>): Apollo.QueryResult<DiscussionSuggestionsQuery, Exact<{
    [key: string]: never;
}>>;
export declare function useDiscussionSuggestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DiscussionSuggestionsQuery, DiscussionSuggestionsQueryVariables>): Apollo.QueryTuple<DiscussionSuggestionsQuery, Exact<{
    [key: string]: never;
}>>;
export declare type DiscussionSuggestionsQueryHookResult = ReturnType<typeof useDiscussionSuggestionsQuery>;
export declare type DiscussionSuggestionsLazyQueryHookResult = ReturnType<typeof useDiscussionSuggestionsLazyQuery>;
export declare type DiscussionSuggestionsQueryResult = Apollo.QueryResult<DiscussionSuggestionsQuery, DiscussionSuggestionsQueryVariables>;
